From 00a24728caacf9c8d123c78c82cc09b3487b8081 Mon Sep 17 00:00:00 2001
From: w00800630 <w00800630@notesmail.huawei.com/>
Date: Wed, 4 Jun 2025 15:38:33 +0800
Subject: [PATCH] TicketNo:DTS2025022819801 Description:Fix: PressedButtons Is
 Not Handled Properly In TS Interface:InjectionMouseEvent, Causing Unexpected
 Real-Time Window Hitting Of MOVE Events.

Team:OTHERS
Feature or Bugfix:Bugfix
Binary Source:No
PrivateCode(Yes/No):No

Change-Id: I48bb6f7a37ff51b8607560f8445021f3df8188ad
---
 .../include/js_register_module.h              | 13 ++-
 .../include/js_register_util.h                |  7 +-
 .../src/js_register_module.cpp                | 62 +++++++++----
 .../src/js_register_util.cpp                  | 86 +++++++++++++++++--
 4 files changed, 146 insertions(+), 22 deletions(-)

diff --git a/frameworks/napi/input_event_client/include/js_register_module.h b/frameworks/napi/input_event_client/include/js_register_module.h
index e94a8523f2..4e3804d855 100644
--- a/frameworks/napi/input_event_client/include/js_register_module.h
+++ b/frameworks/napi/input_event_client/include/js_register_module.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -41,4 +41,15 @@ enum TOUCH_CALLBACK_SOURCETYPE {
     PEN = 1,
     TOUCH_PAD = 2
 };
+
+enum JS_MOUSE_BUTTON {
+    JS_MOUSE_BUTTON_LEFT = 0,
+    JS_MOUSE_BUTTON_MIDDLE = 1,
+    JS_MOUSE_BUTTON_RIGHT = 2,
+    JS_MOUSE_BUTTON_SIDE = 3,
+    JS_MOUSE_BUTTON_EXTRA = 4,
+    JS_MOUSE_BUTTON_FORWARD = 5,
+    JS_MOUSE_BUTTON_BACK = 6,
+    JS_MOUSE_BUTTON_TASK = 7
+};
 #endif // JS_REGISTER_MODULE_H
\ No newline at end of file
diff --git a/frameworks/napi/input_event_client/include/js_register_util.h b/frameworks/napi/input_event_client/include/js_register_util.h
index 218d79882d..dd854820fa 100644
--- a/frameworks/napi/input_event_client/include/js_register_util.h
+++ b/frameworks/napi/input_event_client/include/js_register_util.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -25,6 +25,11 @@ int32_t GetNamedPropertyInt32(const napi_env& env, const napi_value& object, con
     int32_t& ret, bool required = true);
 int32_t GetNamedPropertyInt64(const napi_env& env, const napi_value& object, const std::string& name, int64_t& ret);
 int32_t GetNamedPropertyDouble(const napi_env& env, const napi_value& object, const std::string& name, double& ret);
+bool CheckType(const napi_env& env, const napi_value& value, const napi_valuetype& type);
+bool IsArray(const napi_env& env, const napi_value& value);
+bool ParseInt32(const napi_env& env, const napi_value& value, int32_t& result);
+int32_t GetNamedPropertyArrayInt32(const napi_env& env, const napi_value& object, const std::string &name,
+    std::vector<int32_t>& result);
 } // namespace MMI
 } // namespace OHOS
 #endif // JS_REGISTER_UTIL_H
\ No newline at end of file
diff --git a/frameworks/napi/input_event_client/src/js_register_module.cpp b/frameworks/napi/input_event_client/src/js_register_module.cpp
index ff1168ae2e..d723c262fa 100644
--- a/frameworks/napi/input_event_client/src/js_register_module.cpp
+++ b/frameworks/napi/input_event_client/src/js_register_module.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -33,9 +33,17 @@
 namespace OHOS {
 namespace MMI {
 namespace {
-constexpr int32_t JS_CALLBACK_MOUSE_BUTTON_MIDDLE { 1 };
-constexpr int32_t JS_CALLBACK_MOUSE_BUTTON_RIGHT { 2 };
-} // namespace
+static std::unordered_map<int32_t, int32_t> JSMouseButton2Native = {
+    { JS_MOUSE_BUTTON_LEFT, PointerEvent::MOUSE_BUTTON_LEFT },
+    { JS_MOUSE_BUTTON_RIGHT, PointerEvent::MOUSE_BUTTON_RIGHT },
+    { JS_MOUSE_BUTTON_MIDDLE, PointerEvent::MOUSE_BUTTON_MIDDLE },
+    { JS_MOUSE_BUTTON_SIDE, PointerEvent::MOUSE_BUTTON_SIDE },
+    { JS_MOUSE_BUTTON_EXTRA, PointerEvent::MOUSE_BUTTON_EXTRA },
+    { JS_MOUSE_BUTTON_FORWARD, PointerEvent::MOUSE_BUTTON_FORWARD },
+    { JS_MOUSE_BUTTON_BACK, PointerEvent::MOUSE_BUTTON_BACK },
+    { JS_MOUSE_BUTTON_TASK, PointerEvent::MOUSE_BUTTON_TASK }
+};
+}
 
 #ifdef OHOS_BUILD_ENABLE_VKEYBOARD
 static void GetInjectionEventDataNative(napi_env env, struct Input_KeyEvent* keyEventNative, napi_value keyHandle)
@@ -226,17 +234,10 @@ static void HandleMouseButton(napi_env env, napi_value mouseHandle,
         MMI_HILOGE("button:%{public}d is less 0, can not process", button);
         THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "button must be greater than or equal to 0");
     }
-
-    switch (button) {
-        case JS_CALLBACK_MOUSE_BUTTON_MIDDLE:
-            button = PointerEvent::MOUSE_BUTTON_MIDDLE;
-            break;
-        case JS_CALLBACK_MOUSE_BUTTON_RIGHT:
-            button = PointerEvent::MOUSE_BUTTON_RIGHT;
-            break;
-        default:
-            MMI_HILOGE("button:%{public}d is unknown", button);
-            break;
+    if (JSMouseButton2Native.find(button) != JSMouseButton2Native.end()) {
+        button = JSMouseButton2Native[button];
+    } else {
+        MMI_HILOGE("button:%{public}d is unknown", button);
     }
     pointerEvent->SetButtonId(button);
     if (action == JS_CALLBACK_MOUSE_ACTION_BUTTON_DOWN) {
@@ -246,6 +247,36 @@ static void HandleMouseButton(napi_env env, napi_value mouseHandle,
     }
 }
 
+static void HandleMousePressedButtons(napi_env env, napi_value mouseHandle,
+    std::shared_ptr<PointerEvent> pointerEvent, PointerEvent::PointerItem &item)
+{
+    CHKPV(pointerEvent);
+    std::vector<int32_t> jsPressedButtons { };
+    if (GetNamedPropertyArrayInt32(env, mouseHandle, "pressedButtons", jsPressedButtons) != RET_OK) {
+        MMI_HILOGE("Get pressedButtons failed");
+        return;
+    }
+    std::vector<int32_t> nativePressedButtons { };
+    for (const auto jsButton : jsPressedButtons) {
+        if (JSMouseButton2Native.find(jsButton) == JSMouseButton2Native.end()) {
+            MMI_HILOGE("Unknown jsButton:%{public}d", jsButton);
+            continue;
+        }
+        nativePressedButtons.push_back(JSMouseButton2Native[jsButton]);
+    }
+    MMI_HILOGD("NativePressedButtons size:%{public}zu", nativePressedButtons.size());
+    auto buttonId = pointerEvent->GetButtonId();
+    auto iter = std::find_if(nativePressedButtons.begin(), nativePressedButtons.end(),
+        [buttonId] (int32_t elem) { return elem == buttonId; }
+    );
+    if (iter != nativePressedButtons.end()) {
+        item.SetPressed(true);
+    }
+    for (const auto button : nativePressedButtons) {
+        pointerEvent->SetButtonPressed(button);
+    }
+}
+
 static void HandleMouseAction(napi_env env, napi_value mouseHandle,
     std::shared_ptr<PointerEvent> pointerEvent, PointerEvent::PointerItem &item)
 {
@@ -349,6 +380,7 @@ static napi_value InjectMouseEvent(napi_env env, napi_callback_info info)
 
     HandleMouseAction(env, mouseHandle, pointerEvent, item);
     HandleMousePropertyInt32(env, mouseHandle, pointerEvent, item);
+    HandleMousePressedButtons(env, mouseHandle, pointerEvent, item);
     InputManager::GetInstance()->SimulateInputEvent(pointerEvent);
     CHKRP(napi_create_int32(env, 0, &result), CREATE_INT32);
     return result;
diff --git a/frameworks/napi/input_event_client/src/js_register_util.cpp b/frameworks/napi/input_event_client/src/js_register_util.cpp
index 18eeeb501a..38ee6e014a 100644
--- a/frameworks/napi/input_event_client/src/js_register_util.cpp
+++ b/frameworks/napi/input_event_client/src/js_register_util.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -28,7 +28,7 @@ int32_t GetNamedPropertyBool(const napi_env& env, const napi_value& object, cons
     CHKRF(napi_get_named_property(env, object, name.c_str(), &napiValue), GET_NAMED_PROPERTY);
     if (napiValue == nullptr) {
         MMI_HILOGE("The value is null");
-        THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid KeyEvent");
+        THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid parameter");
         return RET_ERR;
     }
     napi_valuetype tmpType = napi_undefined;
@@ -53,7 +53,7 @@ int32_t GetNamedPropertyInt32(const napi_env& env, const napi_value& object,
     if (napiValue == nullptr) {
         MMI_HILOGE("The value is null");
         if (required) {
-            THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid KeyEvent");
+            THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid parameter");
         }
         return RET_ERR;
     }
@@ -65,7 +65,7 @@ int32_t GetNamedPropertyInt32(const napi_env& env, const napi_value& object,
     if (tmpType != napi_number) {
         MMI_HILOGE("The value is not int32_t");
         if (required) {
-            THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid KeyEvent");
+            THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid parameter");
         }
         return RET_ERR;
     }
@@ -85,7 +85,7 @@ int32_t GetNamedPropertyInt64(const napi_env& env, const napi_value& object, con
     }
     if (napiValue == nullptr) {
         MMI_HILOGE("The value is null");
-        THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid KeyEvent");
+        THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid parameter");
         return RET_ERR;
     }
     napi_valuetype tmpType = napi_undefined;
@@ -133,5 +133,81 @@ int32_t GetNamedPropertyDouble(const napi_env& env, const napi_value& object, co
     }
     return RET_OK;
 }
+
+bool CheckType(const napi_env& env, const napi_value& value, const napi_valuetype& type)
+{
+    napi_valuetype valuetype = napi_undefined;
+    napi_typeof(env, value, &valuetype);
+    if (valuetype != type) {
+        return false;
+    }
+    return true;
+}
+
+bool IsArray(const napi_env& env, const napi_value& value)
+{
+    bool isArray = false;
+    if (napi_is_array(env, value, &isArray) != napi_ok) {
+        MMI_HILOGE("napi_is_array failed");
+        return false;
+    }
+    return isArray;
+}
+
+bool ParseInt32(const napi_env& env, const napi_value& value, int32_t& result)
+{
+    if (!CheckType(env, value, napi_number)) {
+        MMI_HILOGE("ParseInt32 type not number");
+        THROWERR_API9(env, COMMON_PARAMETER_ERROR, "element of pattern", "Number");
+        return false;
+    }
+    if (napi_get_value_int32(env, value, &result) != napi_ok) {
+        MMI_HILOGE("ParseInt64 cannot get value int32");
+        THROWERR_API9(env, COMMON_PARAMETER_ERROR, "element of pattern", "Int32");
+        return false;
+    }
+    return true;
+}
+
+int32_t GetNamedPropertyArrayInt32(const napi_env& env, const napi_value& object, const std::string& name,
+    std::vector<int32_t>& result)
+{
+    napi_value napiValue = {};
+    if (napi_get_named_property(env, object, name.c_str(), &napiValue) != napi_ok) {
+        MMI_HILOGE("Call napi_get_named_property failed, name:%{public}s", name.c_str());
+        return RET_ERR;
+    }
+    if (napiValue == nullptr) {
+        MMI_HILOGE("The value is null");
+        THROWERR_CUSTOM(env, COMMON_PARAMETER_ERROR, "Invalid value");
+        return RET_ERR;
+    }
+    if (!IsArray(env, napiValue)) {
+        MMI_HILOGE("Current obj is not array");
+        THROWERR_API9(env, COMMON_PARAMETER_ERROR, "pattern", "Array");
+        return RET_ERR;
+    }
+    uint32_t length = 0;
+    napi_get_array_length(env, napiValue, &length);
+    for (uint32_t i = 0; i < length; i++) {
+        napi_value arrayElem = nullptr;
+        if (napi_get_element(env, napiValue, i, &arrayElem) != napi_ok) {
+            MMI_HILOGE("napi_get_element failed. index:%{public}d", i);
+            return RET_ERR;
+        }
+        int32_t res = { -1 };
+        if (!ParseInt32(env, arrayElem, res)) {
+            MMI_HILOGE("parse array elem fail. index:%{public}d", i);
+            THROWERR_API9(env, COMMON_PARAMETER_ERROR, "element of pattern", "Int64");
+            return RET_ERR;
+        }
+        if (res < 0) {
+            THROWERR_API9(env, COMMON_PARAMETER_ERROR, "value for element of pattern", "must be positive");
+            return RET_ERR;
+        }
+        result.emplace_back(res);
+    }
+    return RET_OK;
+}
 } // namespace MMI
 } // namespace OHOS
-- 
2.45.2.huawei.8

