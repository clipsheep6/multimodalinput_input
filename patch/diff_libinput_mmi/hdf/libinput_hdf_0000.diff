Copyright (c) 2021-2022 Huawei Device Co., Ltd.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

diff -Naur old/BUILD.gn new/BUILD.gn
--- old/BUILD.gn	2021-01-01 00:00:00.000000000 +0800
+++ new/BUILD.gn	2021-01-01 00:00:00.000000000 +0800
@@ -15,19 +15,23 @@
     "-Wno-return-type",
     "-Wno-unused-function",
     "-Wno-string-conversion",
+    "-Bsymbolic",
   ]
 }
 
 config("libinput-third_public_config") {
   include_dirs = [
     "export_include",
+    "include",
+    "include/linux/linux",
+    "src",
   ]
 
   cflags = [
   ]
 }
 
-ohos_shared_library("libinput-third") {
+ohos_shared_library("libinput-third-hdf") {
   sources = [
     "src/util-list.c",
     "src/util-ratelimit.c",
@@ -61,7 +65,8 @@
     "src/path-seat.c",
     "src/udev-seat.c",
     "src/timer.c",
-#    "src/libinput-util.c",
+    "src/libinput-util.c",
+    "src/evdev-joystick.c",
   ]
 
   configs = [
@@ -76,9 +81,9 @@
   ]
 
   public_deps = [
-    "//third_party/libevdev:libevdev",
+    "//third_party/patch_libevdev_hdf:libevdev-hdf",
     "//third_party/eudev:libudev",
-    "//third_party/mtdev:libmtdev",
+    "//third_party/patch_mtdev_hdf:libmtdev-hdf",
   ]
 
   part_name = "input"
@@ -86,92 +91,3 @@
 ## Build libinput-third.so }}}
 
 
-ohos_executable("libinput-debug") {
-  install_enable = true
-
-  sources = [
-    "tools/shared.h",
-    "tools/shared.c",
-    "tools/libinput-debug-events.c",
-  ]
-
-  configs = [
-    ":libinput-third_config",
-  ]
-
-  public_configs = [
-    ":libinput-third_public_config",
-  ]
-
-  deps = [
-    ":libinput-third",
-  ]
-
-  public_deps = [
-    "//third_party/libevdev:libevdev",
-    "//third_party/eudev:libudev",
-    "//third_party/mtdev:libmtdev",
-  ]
-
-  part_name = "multimodalinput_base"
-}
-
-ohos_executable("libinput-list") {
-  install_enable = true
-
-  sources = [
-    "tools/shared.h",
-    "tools/shared.c",
-    "tools/libinput-list-devices.c",
-  ]
-
-  configs = [
-    ":libinput-third_config",
-  ]
-
-  public_configs = [
-    ":libinput-third_public_config",
-  ]
-
-  deps = [
-    ":libinput-third",
-  ]
-
-  public_deps = [
-    "//third_party/libevdev:libevdev",
-    "//third_party/eudev:libudev",
-    "//third_party/mtdev:libmtdev",
-  ]
-
-  part_name = "multimodalinput_base"
-}
-
-ohos_executable("libinput-tablet") {
-  install_enable = true
-
-  sources = [
-    "tools/shared.h",
-    "tools/shared.c",
-    "tools/libinput-debug-tablet.c",
-  ]
-
-  configs = [
-    ":libinput-third_config",
-  ]
-
-  public_configs = [
-    ":libinput-third_public_config",
-  ]
-
-  deps = [
-    ":libinput-third",
-  ]
-
-  public_deps = [
-    "//third_party/libevdev:libevdev",
-    "//third_party/eudev:libudev",
-    "//third_party/mtdev:libmtdev",
-  ]
-
-  part_name = "multimodalinput_base"
-}
\ No newline at end of file
diff -Naur old/export_include/libinput.h new/export_include/libinput.h
--- old/export_include/libinput.h	2021-01-01 00:00:00.000000000 +0800
+++ new/export_include/libinput.h	2021-01-01 00:00:00.000000000 +0800
@@ -33,6 +33,7 @@
 #include <stdint.h>
 #include <stdarg.h>
 #include <libudev.h>
+#include "util-bits.h"
 
 #define LIBINPUT_ATTRIBUTE_PRINTF(_format, _args) \
 	__attribute__ ((format (printf, _format, _args)))
@@ -196,6 +197,22 @@
 	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
 	LIBINPUT_DEVICE_CAP_GESTURE = 5,
 	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+	LIBINPUT_DEVICE_CAP_JOYSTICK = 7,
+};
+
+enum evdev_device_udev_tags {
+    EVDEV_UDEV_TAG_INPUT = bit(0),
+    EVDEV_UDEV_TAG_KEYBOARD = bit(1),
+    EVDEV_UDEV_TAG_MOUSE = bit(2),
+    EVDEV_UDEV_TAG_TOUCHPAD = bit(3),
+    EVDEV_UDEV_TAG_TOUCHSCREEN = bit(4),
+    EVDEV_UDEV_TAG_TABLET = bit(5),
+    EVDEV_UDEV_TAG_JOYSTICK = bit(6),
+    EVDEV_UDEV_TAG_ACCELEROMETER = bit(7),
+    EVDEV_UDEV_TAG_TABLET_PAD = bit(8),
+    EVDEV_UDEV_TAG_POINTINGSTICK = bit(9),
+    EVDEV_UDEV_TAG_TRACKBALL = bit(10),
+    EVDEV_UDEV_TAG_SWITCH = bit(11),
 };
 
 /**
@@ -315,6 +332,49 @@
 };
 
 /**
+ * @ingroup event_joystick
+ *
+ * The source for a @ref LIBINPUT_EVENT_POINTER_AXIS event. See
+ * libinput_event_get_joystick_axis_event() for details.
+ *
+ * @since 1.16.4
+ */
+enum libinput_joystick_axis_source {
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_UNKNOW = 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X = bit(0),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y = bit(1),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z = bit(2),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX = bit(3),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY = bit(4),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ = bit(5),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE = bit(6),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RUDDER = bit(7),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_WHEEL = bit(8),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS = bit(9),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE = bit(10),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X = bit(11),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y = bit(12),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1X = bit(13),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1Y = bit(14),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2X = bit(15),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2Y = bit(16),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3X = bit(17),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3Y = bit(18),
+};
+
+#define MAX_SOLTED_COORDS_NUM 10
+struct sloted_coords {
+	bool is_active;
+	float x;
+	float y;
+};
+
+struct sloted_coords_info {
+	struct sloted_coords coords[MAX_SOLTED_COORDS_NUM];
+	unsigned int active_count;
+};
+
+/**
  * @ingroup device
  *
  * Available tool types for a device with the @ref
@@ -387,6 +447,17 @@
 	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
 };
 
+struct libinput_event_joystick_axis_abs_info {
+	int32_t code;
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+	float	standardValue;
+};
+
 /**
  * @defgroup tablet_pad_modes Tablet pad modes
  *
@@ -1893,6 +1964,12 @@
 libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);
 
 /**
+ * 获取带slot的touches信息, 仅支持LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE
+ */
+struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(struct libinput_event_gesture *event);
+
+/**
  * @defgroup event_tablet Tablet events
  *
  * Events that come from tools on tablet devices. For events from the pad,
@@ -3466,6 +3543,46 @@
 int
 libinput_dispatch(struct libinput *libinput);
 
+/****************************************************************************
+* @brief : brief
+* @author : fms
+* @date : 2021/3/8 20:55
+* @version : ver 1.0
+* @inparam :libinput  event
+* @outparam :
+*****************************************************************************/
+void
+libinput_post_handle_event(struct libinput* libinput,
+	struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick button event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam : 
+* @outparam : 
+*****************************************************************************/
+struct libinput_event_joystick_axis *
+libinput_event_get_joystick_axis_event(struct libinput_event *event);
+
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event);
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+bool libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
 /**
  * @ingroup base
  *
@@ -3936,6 +4053,10 @@
 const char *
 libinput_device_get_name(struct libinput_device *device);
 
+/**  @brief   获取设备类型*/
+enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device);
+
 /**
  * @ingroup device
  *
@@ -5928,7 +6049,97 @@
 unsigned int
 libinput_device_config_rotation_get_default_angle(struct libinput_device *device);
 
+struct uhdf;
+
+int uhdfdevice_added(struct libinput *input,struct uhdf *uhdf,const char *seat_name);
+
+struct libinput * libinput_hdf_create_context(const struct libinput_interface *interface,void *user_data);
+
+void uhdfdevice_removed(struct uhdf *uhdf);
+
+struct evdev_device;
+struct input_event;
+void evdev_device_dispatch_two(struct evdev_device *device,
+                struct input_event *ev);
+
+/**
+ * @ingroup event
+ *
+ * Get the struct libinput_event_joystick_button from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput_event_joystick_button for this event.
+ */
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the time from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The time for this event.
+ */
+uint64_t libinput_event_joystick_button_time(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the key value from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The key value for this event.
+ */
+uint32_t libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the seat key count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The seat key count for this event.
+ */
+uint32_t libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the value count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The value for this event.
+ */
+int libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the pressure of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Pressure value of touch screen
+ * 
+ * @since 1.4
+ */
+double
+libinput_event_get_touch_pressure(struct libinput_event* event);
+
+const char*
+libinput_device_get_phys(struct libinput_device* device);
+bool libinput_pipe(struct libinput *libinput);
+int libinput_pipe_write(struct libinput *libinput, int index,const void *buf, int count);
+
+int libinput_pipe_read(struct libinput *libinput, int index,void *buf, int count);
+int libinput_devpipe_write(struct libinput *libinput,void *buf, int count);
+int libinput_devpipe_read(struct libinput *libinput, void *buf, int count);
+int libinput_get_pipe_bytes(struct libinput *libinput, int index);
+
+enum libinput_key_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event);
 #ifdef __cplusplus
 }
 #endif
 #endif /* LIBINPUT_H */
+
diff -Naur old/include/config.h new/include/config.h
--- old/include/config.h	2021-01-01 00:00:00.000000000 +0800
+++ new/include/config.h	2021-01-01 00:00:00.000000000 +0800
@@ -18,14 +18,17 @@
 #endif
 #define HTTP_DOC_LINK "https://wayland.freedesktop.org/libinput/doc/latest"
 
-#define LIBINPUT_QUIRKS_DIR "/usr/share/libinput"
+#define LIBINPUT_QUIRKS_DIR "/etc/libinput/quirks"
 
-#define LIBINPUT_QUIRKS_OVERRIDE_FILE "/etc/libinput/local-overrides.quirks"
+#define LIBINPUT_QUIRKS_OVERRIDE_FILE "/etc/libinput/quirks/local-overrides.quirks"
+
+#define LIBINPUT_QUIRKS_SRCDIR "/etc/libinput/quirks"
+
+#define LIBINPUT_TOOL_PATH "/data/libinput"
+
+#define MESON_BUILD_ROOT "/data/libinput"
 
 #undef NDEBUG
-#define LIBINPUT_TOOL_PATH ""
-#define LIBINPUT_QUIRKS_SRCDIR ""
-#define MESON_BUILD_ROOT ""
 #ifndef static_assert
 # ifdef _Static_assert
 #  define static_assert(cond, msg) _Static_assert(cond, msg)
@@ -36,3 +39,10 @@
 
 #define index strchr
 #define ffs __builtin_ffs
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+#define _LIBINPUT_LOG_DIR "/data/log/libinput"
+#define _LIBINPUT_LOG_PATH "/data/log/libinput/libinput.log"
+#endif
+
+
diff -Naur old/include/linux/linux/input-event-codes.h new/include/linux/linux/input-event-codes.h
--- old/include/linux/linux/input-event-codes.h	2021-01-01 00:00:00.000000000 +0800
+++ new/include/linux/linux/input-event-codes.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,945 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
-/*
- * Input event codes
- *
- *    *** IMPORTANT ***
- * This file is not only included from C-code but also from devicetree source
- * files. As such this file MUST only contain comments and defines.
- *
- * Copyright (c) 1999-2002 Vojtech Pavlik
- * Copyright (c) 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- */
-#ifndef _UAPI_INPUT_EVENT_CODES_H
-#define _UAPI_INPUT_EVENT_CODES_H
-
-/*
- * Device properties and quirks
- */
-
-#define INPUT_PROP_POINTER		0x00	/* needs a pointer */
-#define INPUT_PROP_DIRECT		0x01	/* direct input devices */
-#define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
-#define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
-#define INPUT_PROP_TOPBUTTONPAD		0x04	/* softbuttons at top of pad */
-#define INPUT_PROP_POINTING_STICK	0x05	/* is a pointing stick */
-#define INPUT_PROP_ACCELEROMETER	0x06	/* has accelerometer */
-
-#define INPUT_PROP_MAX			0x1f
-#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
-
-/*
- * Event types
- */
-
-#define EV_SYN			0x00
-#define EV_KEY			0x01
-#define EV_REL			0x02
-#define EV_ABS			0x03
-#define EV_MSC			0x04
-#define EV_SW			0x05
-#define EV_LED			0x11
-#define EV_SND			0x12
-#define EV_REP			0x14
-#define EV_FF			0x15
-#define EV_PWR			0x16
-#define EV_FF_STATUS		0x17
-#define EV_MAX			0x1f
-#define EV_CNT			(EV_MAX+1)
-
-/*
- * Synchronization events.
- */
-
-#define SYN_REPORT		0
-#define SYN_CONFIG		1
-#define SYN_MT_REPORT		2
-#define SYN_DROPPED		3
-#define SYN_MAX			0xf
-#define SYN_CNT			(SYN_MAX+1)
-
-/*
- * Keys and buttons
- *
- * Most of the keys/buttons are modeled after USB HUT 1.12
- * (see http://www.usb.org/developers/hidpage).
- * Abbreviations in the comments:
- * AC - Application Control
- * AL - Application Launch Button
- * SC - System Control
- */
-
-#define KEY_RESERVED		0
-#define KEY_ESC			1
-#define KEY_1			2
-#define KEY_2			3
-#define KEY_3			4
-#define KEY_4			5
-#define KEY_5			6
-#define KEY_6			7
-#define KEY_7			8
-#define KEY_8			9
-#define KEY_9			10
-#define KEY_0			11
-#define KEY_MINUS		12
-#define KEY_EQUAL		13
-#define KEY_BACKSPACE		14
-#define KEY_TAB			15
-#define KEY_Q			16
-#define KEY_W			17
-#define KEY_E			18
-#define KEY_R			19
-#define KEY_T			20
-#define KEY_Y			21
-#define KEY_U			22
-#define KEY_I			23
-#define KEY_O			24
-#define KEY_P			25
-#define KEY_LEFTBRACE		26
-#define KEY_RIGHTBRACE		27
-#define KEY_ENTER		28
-#define KEY_LEFTCTRL		29
-#define KEY_A			30
-#define KEY_S			31
-#define KEY_D			32
-#define KEY_F			33
-#define KEY_G			34
-#define KEY_H			35
-#define KEY_J			36
-#define KEY_K			37
-#define KEY_L			38
-#define KEY_SEMICOLON		39
-#define KEY_APOSTROPHE		40
-#define KEY_GRAVE		41
-#define KEY_LEFTSHIFT		42
-#define KEY_BACKSLASH		43
-#define KEY_Z			44
-#define KEY_X			45
-#define KEY_C			46
-#define KEY_V			47
-#define KEY_B			48
-#define KEY_N			49
-#define KEY_M			50
-#define KEY_COMMA		51
-#define KEY_DOT			52
-#define KEY_SLASH		53
-#define KEY_RIGHTSHIFT		54
-#define KEY_KPASTERISK		55
-#define KEY_LEFTALT		56
-#define KEY_SPACE		57
-#define KEY_CAPSLOCK		58
-#define KEY_F1			59
-#define KEY_F2			60
-#define KEY_F3			61
-#define KEY_F4			62
-#define KEY_F5			63
-#define KEY_F6			64
-#define KEY_F7			65
-#define KEY_F8			66
-#define KEY_F9			67
-#define KEY_F10			68
-#define KEY_NUMLOCK		69
-#define KEY_SCROLLLOCK		70
-#define KEY_KP7			71
-#define KEY_KP8			72
-#define KEY_KP9			73
-#define KEY_KPMINUS		74
-#define KEY_KP4			75
-#define KEY_KP5			76
-#define KEY_KP6			77
-#define KEY_KPPLUS		78
-#define KEY_KP1			79
-#define KEY_KP2			80
-#define KEY_KP3			81
-#define KEY_KP0			82
-#define KEY_KPDOT		83
-
-#define KEY_ZENKAKUHANKAKU	85
-#define KEY_102ND		86
-#define KEY_F11			87
-#define KEY_F12			88
-#define KEY_RO			89
-#define KEY_KATAKANA		90
-#define KEY_HIRAGANA		91
-#define KEY_HENKAN		92
-#define KEY_KATAKANAHIRAGANA	93
-#define KEY_MUHENKAN		94
-#define KEY_KPJPCOMMA		95
-#define KEY_KPENTER		96
-#define KEY_RIGHTCTRL		97
-#define KEY_KPSLASH		98
-#define KEY_SYSRQ		99
-#define KEY_RIGHTALT		100
-#define KEY_LINEFEED		101
-#define KEY_HOME		102
-#define KEY_UP			103
-#define KEY_PAGEUP		104
-#define KEY_LEFT		105
-#define KEY_RIGHT		106
-#define KEY_END			107
-#define KEY_DOWN		108
-#define KEY_PAGEDOWN		109
-#define KEY_INSERT		110
-#define KEY_DELETE		111
-#define KEY_MACRO		112
-#define KEY_MUTE		113
-#define KEY_VOLUMEDOWN		114
-#define KEY_VOLUMEUP		115
-#define KEY_POWER		116	/* SC System Power Down */
-#define KEY_KPEQUAL		117
-#define KEY_KPPLUSMINUS		118
-#define KEY_PAUSE		119
-#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
-
-#define KEY_KPCOMMA		121
-#define KEY_HANGEUL		122
-#define KEY_HANGUEL		KEY_HANGEUL
-#define KEY_HANJA		123
-#define KEY_YEN			124
-#define KEY_LEFTMETA		125
-#define KEY_RIGHTMETA		126
-#define KEY_COMPOSE		127
-
-#define KEY_STOP		128	/* AC Stop */
-#define KEY_AGAIN		129
-#define KEY_PROPS		130	/* AC Properties */
-#define KEY_UNDO		131	/* AC Undo */
-#define KEY_FRONT		132
-#define KEY_COPY		133	/* AC Copy */
-#define KEY_OPEN		134	/* AC Open */
-#define KEY_PASTE		135	/* AC Paste */
-#define KEY_FIND		136	/* AC Search */
-#define KEY_CUT			137	/* AC Cut */
-#define KEY_HELP		138	/* AL Integrated Help Center */
-#define KEY_MENU		139	/* Menu (show menu) */
-#define KEY_CALC		140	/* AL Calculator */
-#define KEY_SETUP		141
-#define KEY_SLEEP		142	/* SC System Sleep */
-#define KEY_WAKEUP		143	/* System Wake Up */
-#define KEY_FILE		144	/* AL Local Machine Browser */
-#define KEY_SENDFILE		145
-#define KEY_DELETEFILE		146
-#define KEY_XFER		147
-#define KEY_PROG1		148
-#define KEY_PROG2		149
-#define KEY_WWW			150	/* AL Internet Browser */
-#define KEY_MSDOS		151
-#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
-#define KEY_SCREENLOCK		KEY_COFFEE
-#define KEY_ROTATE_DISPLAY	153	/* Display orientation for e.g. tablets */
-#define KEY_DIRECTION		KEY_ROTATE_DISPLAY
-#define KEY_CYCLEWINDOWS	154
-#define KEY_MAIL		155
-#define KEY_BOOKMARKS		156	/* AC Bookmarks */
-#define KEY_COMPUTER		157
-#define KEY_BACK		158	/* AC Back */
-#define KEY_FORWARD		159	/* AC Forward */
-#define KEY_CLOSECD		160
-#define KEY_EJECTCD		161
-#define KEY_EJECTCLOSECD	162
-#define KEY_NEXTSONG		163
-#define KEY_PLAYPAUSE		164
-#define KEY_PREVIOUSSONG	165
-#define KEY_STOPCD		166
-#define KEY_RECORD		167
-#define KEY_REWIND		168
-#define KEY_PHONE		169	/* Media Select Telephone */
-#define KEY_ISO			170
-#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
-#define KEY_HOMEPAGE		172	/* AC Home */
-#define KEY_REFRESH		173	/* AC Refresh */
-#define KEY_EXIT		174	/* AC Exit */
-#define KEY_MOVE		175
-#define KEY_EDIT		176
-#define KEY_SCROLLUP		177
-#define KEY_SCROLLDOWN		178
-#define KEY_KPLEFTPAREN		179
-#define KEY_KPRIGHTPAREN	180
-#define KEY_NEW			181	/* AC New */
-#define KEY_REDO		182	/* AC Redo/Repeat */
-
-#define KEY_F13			183
-#define KEY_F14			184
-#define KEY_F15			185
-#define KEY_F16			186
-#define KEY_F17			187
-#define KEY_F18			188
-#define KEY_F19			189
-#define KEY_F20			190
-#define KEY_F21			191
-#define KEY_F22			192
-#define KEY_F23			193
-#define KEY_F24			194
-
-#define KEY_PLAYCD		200
-#define KEY_PAUSECD		201
-#define KEY_PROG3		202
-#define KEY_PROG4		203
-#define KEY_DASHBOARD		204	/* AL Dashboard */
-#define KEY_SUSPEND		205
-#define KEY_CLOSE		206	/* AC Close */
-#define KEY_PLAY		207
-#define KEY_FASTFORWARD		208
-#define KEY_BASSBOOST		209
-#define KEY_PRINT		210	/* AC Print */
-#define KEY_HP			211
-#define KEY_CAMERA		212
-#define KEY_SOUND		213
-#define KEY_QUESTION		214
-#define KEY_EMAIL		215
-#define KEY_CHAT		216
-#define KEY_SEARCH		217
-#define KEY_CONNECT		218
-#define KEY_FINANCE		219	/* AL Checkbook/Finance */
-#define KEY_SPORT		220
-#define KEY_SHOP		221
-#define KEY_ALTERASE		222
-#define KEY_CANCEL		223	/* AC Cancel */
-#define KEY_BRIGHTNESSDOWN	224
-#define KEY_BRIGHTNESSUP	225
-#define KEY_MEDIA		226
-
-#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
-					   outputs (Monitor/LCD/TV-out/etc) */
-#define KEY_KBDILLUMTOGGLE	228
-#define KEY_KBDILLUMDOWN	229
-#define KEY_KBDILLUMUP		230
-
-#define KEY_SEND		231	/* AC Send */
-#define KEY_REPLY		232	/* AC Reply */
-#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
-#define KEY_SAVE		234	/* AC Save */
-#define KEY_DOCUMENTS		235
-
-#define KEY_BATTERY		236
-
-#define KEY_BLUETOOTH		237
-#define KEY_WLAN		238
-#define KEY_UWB			239
-
-#define KEY_UNKNOWN		240
-
-#define KEY_VIDEO_NEXT		241	/* drive next video source */
-#define KEY_VIDEO_PREV		242	/* drive previous video source */
-#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
-#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
-					  brightness control is off,
-					  rely on ambient */
-#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
-#define KEY_DISPLAY_OFF		245	/* display device to off state */
-
-#define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
-#define KEY_WIMAX		KEY_WWAN
-#define KEY_RFKILL		247	/* Key that controls all radios */
-
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
-
-/* Code 255 is reserved for special needs of AT keyboard driver */
-
-#define BTN_MISC		0x100
-#define BTN_0			0x100
-#define BTN_1			0x101
-#define BTN_2			0x102
-#define BTN_3			0x103
-#define BTN_4			0x104
-#define BTN_5			0x105
-#define BTN_6			0x106
-#define BTN_7			0x107
-#define BTN_8			0x108
-#define BTN_9			0x109
-
-#define BTN_MOUSE		0x110
-#define BTN_LEFT		0x110
-#define BTN_RIGHT		0x111
-#define BTN_MIDDLE		0x112
-#define BTN_SIDE		0x113
-#define BTN_EXTRA		0x114
-#define BTN_FORWARD		0x115
-#define BTN_BACK		0x116
-#define BTN_TASK		0x117
-
-#define BTN_JOYSTICK		0x120
-#define BTN_TRIGGER		0x120
-#define BTN_THUMB		0x121
-#define BTN_THUMB2		0x122
-#define BTN_TOP			0x123
-#define BTN_TOP2		0x124
-#define BTN_PINKIE		0x125
-#define BTN_BASE		0x126
-#define BTN_BASE2		0x127
-#define BTN_BASE3		0x128
-#define BTN_BASE4		0x129
-#define BTN_BASE5		0x12a
-#define BTN_BASE6		0x12b
-#define BTN_DEAD		0x12f
-
-#define BTN_GAMEPAD		0x130
-#define BTN_SOUTH		0x130
-#define BTN_A			BTN_SOUTH
-#define BTN_EAST		0x131
-#define BTN_B			BTN_EAST
-#define BTN_C			0x132
-#define BTN_NORTH		0x133
-#define BTN_X			BTN_NORTH
-#define BTN_WEST		0x134
-#define BTN_Y			BTN_WEST
-#define BTN_Z			0x135
-#define BTN_TL			0x136
-#define BTN_TR			0x137
-#define BTN_TL2			0x138
-#define BTN_TR2			0x139
-#define BTN_SELECT		0x13a
-#define BTN_START		0x13b
-#define BTN_MODE		0x13c
-#define BTN_THUMBL		0x13d
-#define BTN_THUMBR		0x13e
-
-#define BTN_DIGI		0x140
-#define BTN_TOOL_PEN		0x140
-#define BTN_TOOL_RUBBER		0x141
-#define BTN_TOOL_BRUSH		0x142
-#define BTN_TOOL_PENCIL		0x143
-#define BTN_TOOL_AIRBRUSH	0x144
-#define BTN_TOOL_FINGER		0x145
-#define BTN_TOOL_MOUSE		0x146
-#define BTN_TOOL_LENS		0x147
-#define BTN_TOOL_QUINTTAP	0x148	/* Five fingers on trackpad */
-#define BTN_STYLUS3		0x149
-#define BTN_TOUCH		0x14a
-#define BTN_STYLUS		0x14b
-#define BTN_STYLUS2		0x14c
-#define BTN_TOOL_DOUBLETAP	0x14d
-#define BTN_TOOL_TRIPLETAP	0x14e
-#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
-
-#define BTN_WHEEL		0x150
-#define BTN_GEAR_DOWN		0x150
-#define BTN_GEAR_UP		0x151
-
-#define KEY_OK			0x160
-#define KEY_SELECT		0x161
-#define KEY_GOTO		0x162
-#define KEY_CLEAR		0x163
-#define KEY_POWER2		0x164
-#define KEY_OPTION		0x165
-#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
-#define KEY_TIME		0x167
-#define KEY_VENDOR		0x168
-#define KEY_ARCHIVE		0x169
-#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
-#define KEY_CHANNEL		0x16b
-#define KEY_FAVORITES		0x16c
-#define KEY_EPG			0x16d
-#define KEY_PVR			0x16e	/* Media Select Home */
-#define KEY_MHP			0x16f
-#define KEY_LANGUAGE		0x170
-#define KEY_TITLE		0x171
-#define KEY_SUBTITLE		0x172
-#define KEY_ANGLE		0x173
-#define KEY_FULL_SCREEN		0x174	/* AC View Toggle */
-#define KEY_ZOOM		KEY_FULL_SCREEN
-#define KEY_MODE		0x175
-#define KEY_KEYBOARD		0x176
-#define KEY_ASPECT_RATIO	0x177	/* HUTRR37: Aspect */
-#define KEY_SCREEN		KEY_ASPECT_RATIO
-#define KEY_PC			0x178	/* Media Select Computer */
-#define KEY_TV			0x179	/* Media Select TV */
-#define KEY_TV2			0x17a	/* Media Select Cable */
-#define KEY_VCR			0x17b	/* Media Select VCR */
-#define KEY_VCR2		0x17c	/* VCR Plus */
-#define KEY_SAT			0x17d	/* Media Select Satellite */
-#define KEY_SAT2		0x17e
-#define KEY_CD			0x17f	/* Media Select CD */
-#define KEY_TAPE		0x180	/* Media Select Tape */
-#define KEY_RADIO		0x181
-#define KEY_TUNER		0x182	/* Media Select Tuner */
-#define KEY_PLAYER		0x183
-#define KEY_TEXT		0x184
-#define KEY_DVD			0x185	/* Media Select DVD */
-#define KEY_AUX			0x186
-#define KEY_MP3			0x187
-#define KEY_AUDIO		0x188	/* AL Audio Browser */
-#define KEY_VIDEO		0x189	/* AL Movie Browser */
-#define KEY_DIRECTORY		0x18a
-#define KEY_LIST		0x18b
-#define KEY_MEMO		0x18c	/* Media Select Messages */
-#define KEY_CALENDAR		0x18d
-#define KEY_RED			0x18e
-#define KEY_GREEN		0x18f
-#define KEY_YELLOW		0x190
-#define KEY_BLUE		0x191
-#define KEY_CHANNELUP		0x192	/* Channel Increment */
-#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
-#define KEY_FIRST		0x194
-#define KEY_LAST		0x195	/* Recall Last */
-#define KEY_AB			0x196
-#define KEY_NEXT		0x197
-#define KEY_RESTART		0x198
-#define KEY_SLOW		0x199
-#define KEY_SHUFFLE		0x19a
-#define KEY_BREAK		0x19b
-#define KEY_PREVIOUS		0x19c
-#define KEY_DIGITS		0x19d
-#define KEY_TEEN		0x19e
-#define KEY_TWEN		0x19f
-#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
-#define KEY_GAMES		0x1a1	/* Media Select Games */
-#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
-#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
-#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
-#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
-#define KEY_EDITOR		0x1a6	/* AL Text Editor */
-#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
-#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
-#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
-#define KEY_DATABASE		0x1aa	/* AL Database App */
-#define KEY_NEWS		0x1ab	/* AL Newsreader */
-#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
-#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
-#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
-#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
-#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
-#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
-#define KEY_LOGOFF		0x1b1   /* AL Logoff */
-
-#define KEY_DOLLAR		0x1b2
-#define KEY_EURO		0x1b3
-
-#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
-#define KEY_FRAMEFORWARD	0x1b5
-#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
-#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
-#define KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
-#define KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
-#define KEY_IMAGES		0x1ba	/* AL Image Browser */
-
-#define KEY_DEL_EOL		0x1c0
-#define KEY_DEL_EOS		0x1c1
-#define KEY_INS_LINE		0x1c2
-#define KEY_DEL_LINE		0x1c3
-
-#define KEY_FN			0x1d0
-#define KEY_FN_ESC		0x1d1
-#define KEY_FN_F1		0x1d2
-#define KEY_FN_F2		0x1d3
-#define KEY_FN_F3		0x1d4
-#define KEY_FN_F4		0x1d5
-#define KEY_FN_F5		0x1d6
-#define KEY_FN_F6		0x1d7
-#define KEY_FN_F7		0x1d8
-#define KEY_FN_F8		0x1d9
-#define KEY_FN_F9		0x1da
-#define KEY_FN_F10		0x1db
-#define KEY_FN_F11		0x1dc
-#define KEY_FN_F12		0x1dd
-#define KEY_FN_1		0x1de
-#define KEY_FN_2		0x1df
-#define KEY_FN_D		0x1e0
-#define KEY_FN_E		0x1e1
-#define KEY_FN_F		0x1e2
-#define KEY_FN_S		0x1e3
-#define KEY_FN_B		0x1e4
-
-#define KEY_BRL_DOT1		0x1f1
-#define KEY_BRL_DOT2		0x1f2
-#define KEY_BRL_DOT3		0x1f3
-#define KEY_BRL_DOT4		0x1f4
-#define KEY_BRL_DOT5		0x1f5
-#define KEY_BRL_DOT6		0x1f6
-#define KEY_BRL_DOT7		0x1f7
-#define KEY_BRL_DOT8		0x1f8
-#define KEY_BRL_DOT9		0x1f9
-#define KEY_BRL_DOT10		0x1fa
-
-#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
-#define KEY_NUMERIC_1		0x201	/* and other keypads */
-#define KEY_NUMERIC_2		0x202
-#define KEY_NUMERIC_3		0x203
-#define KEY_NUMERIC_4		0x204
-#define KEY_NUMERIC_5		0x205
-#define KEY_NUMERIC_6		0x206
-#define KEY_NUMERIC_7		0x207
-#define KEY_NUMERIC_8		0x208
-#define KEY_NUMERIC_9		0x209
-#define KEY_NUMERIC_STAR	0x20a
-#define KEY_NUMERIC_POUND	0x20b
-#define KEY_NUMERIC_A		0x20c	/* Phone key A - HUT Telephony 0xb9 */
-#define KEY_NUMERIC_B		0x20d
-#define KEY_NUMERIC_C		0x20e
-#define KEY_NUMERIC_D		0x20f
-
-#define KEY_CAMERA_FOCUS	0x210
-#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
-
-#define KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
-#define KEY_TOUCHPAD_ON		0x213
-#define KEY_TOUCHPAD_OFF	0x214
-
-#define KEY_CAMERA_ZOOMIN	0x215
-#define KEY_CAMERA_ZOOMOUT	0x216
-#define KEY_CAMERA_UP		0x217
-#define KEY_CAMERA_DOWN		0x218
-#define KEY_CAMERA_LEFT		0x219
-#define KEY_CAMERA_RIGHT	0x21a
-
-#define KEY_ATTENDANT_ON	0x21b
-#define KEY_ATTENDANT_OFF	0x21c
-#define KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
-#define KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
-
-#define BTN_DPAD_UP		0x220
-#define BTN_DPAD_DOWN		0x221
-#define BTN_DPAD_LEFT		0x222
-#define BTN_DPAD_RIGHT		0x223
-
-#define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
-#define KEY_ROTATE_LOCK_TOGGLE	0x231	/* Display rotation lock */
-
-#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
-#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
-#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
-#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
-#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
-#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
-#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
-#define KEY_ASSISTANT		0x247	/* AL Context-aware desktop assistant */
-#define KEY_KBD_LAYOUT_NEXT	0x248	/* AC Next Keyboard Layout Select */
-
-#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
-#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
-
-#define KEY_KBDINPUTASSIST_PREV		0x260
-#define KEY_KBDINPUTASSIST_NEXT		0x261
-#define KEY_KBDINPUTASSIST_PREVGROUP		0x262
-#define KEY_KBDINPUTASSIST_NEXTGROUP		0x263
-#define KEY_KBDINPUTASSIST_ACCEPT		0x264
-#define KEY_KBDINPUTASSIST_CANCEL		0x265
-
-/* Diagonal movement keys */
-#define KEY_RIGHT_UP			0x266
-#define KEY_RIGHT_DOWN			0x267
-#define KEY_LEFT_UP			0x268
-#define KEY_LEFT_DOWN			0x269
-
-#define KEY_ROOT_MENU			0x26a /* Show Device's Root Menu */
-/* Show Top Menu of the Media (e.g. DVD) */
-#define KEY_MEDIA_TOP_MENU		0x26b
-#define KEY_NUMERIC_11			0x26c
-#define KEY_NUMERIC_12			0x26d
-/*
- * Toggle Audio Description: refers to an audio service that helps blind and
- * visually impaired consumers understand the action in a program. Note: in
- * some countries this is referred to as "Video Description".
- */
-#define KEY_AUDIO_DESC			0x26e
-#define KEY_3D_MODE			0x26f
-#define KEY_NEXT_FAVORITE		0x270
-#define KEY_STOP_RECORD			0x271
-#define KEY_PAUSE_RECORD		0x272
-#define KEY_VOD				0x273 /* Video on Demand */
-#define KEY_UNMUTE			0x274
-#define KEY_FASTREVERSE			0x275
-#define KEY_SLOWREVERSE			0x276
-/*
- * Control a data application associated with the currently viewed channel,
- * e.g. teletext or data broadcast application (MHEG, MHP, HbbTV, etc.)
- */
-#define KEY_DATA			0x277
-#define KEY_ONSCREEN_KEYBOARD		0x278
-/* Electronic privacy screen control */
-#define KEY_PRIVACY_SCREEN_TOGGLE	0x279
-
-/* Select an area of screen to be copied */
-#define KEY_SELECTIVE_SCREENSHOT	0x27a
-
-/*
- * Some keyboards have keys which do not have a defined meaning, these keys
- * are intended to be programmed / bound to macros by the user. For most
- * keyboards with these macro-keys the key-sequence to inject, or action to
- * take, is all handled by software on the host side. So from the kernel's
- * point of view these are just normal keys.
- *
- * The KEY_MACRO# codes below are intended for such keys, which may be labeled
- * e.g. G1-G18, or S1 - S30. The KEY_MACRO# codes MUST NOT be used for keys
- * where the marking on the key does indicate a defined meaning / purpose.
- *
- * The KEY_MACRO# codes MUST also NOT be used as fallback for when no existing
- * KEY_FOO define matches the marking / purpose. In this case a new KEY_FOO
- * define MUST be added.
- */
-#define KEY_MACRO1			0x290
-#define KEY_MACRO2			0x291
-#define KEY_MACRO3			0x292
-#define KEY_MACRO4			0x293
-#define KEY_MACRO5			0x294
-#define KEY_MACRO6			0x295
-#define KEY_MACRO7			0x296
-#define KEY_MACRO8			0x297
-#define KEY_MACRO9			0x298
-#define KEY_MACRO10			0x299
-#define KEY_MACRO11			0x29a
-#define KEY_MACRO12			0x29b
-#define KEY_MACRO13			0x29c
-#define KEY_MACRO14			0x29d
-#define KEY_MACRO15			0x29e
-#define KEY_MACRO16			0x29f
-#define KEY_MACRO17			0x2a0
-#define KEY_MACRO18			0x2a1
-#define KEY_MACRO19			0x2a2
-#define KEY_MACRO20			0x2a3
-#define KEY_MACRO21			0x2a4
-#define KEY_MACRO22			0x2a5
-#define KEY_MACRO23			0x2a6
-#define KEY_MACRO24			0x2a7
-#define KEY_MACRO25			0x2a8
-#define KEY_MACRO26			0x2a9
-#define KEY_MACRO27			0x2aa
-#define KEY_MACRO28			0x2ab
-#define KEY_MACRO29			0x2ac
-#define KEY_MACRO30			0x2ad
-
-/*
- * Some keyboards with the macro-keys described above have some extra keys
- * for controlling the host-side software responsible for the macro handling:
- * -A macro recording start/stop key. Note that not all keyboards which emit
- *  KEY_MACRO_RECORD_START will also emit KEY_MACRO_RECORD_STOP if
- *  KEY_MACRO_RECORD_STOP is not advertised, then KEY_MACRO_RECORD_START
- *  should be interpreted as a recording start/stop toggle;
- * -Keys for switching between different macro (pre)sets, either a key for
- *  cycling through the configured presets or keys to directly select a preset.
- */
-#define KEY_MACRO_RECORD_START		0x2b0
-#define KEY_MACRO_RECORD_STOP		0x2b1
-#define KEY_MACRO_PRESET_CYCLE		0x2b2
-#define KEY_MACRO_PRESET1		0x2b3
-#define KEY_MACRO_PRESET2		0x2b4
-#define KEY_MACRO_PRESET3		0x2b5
-
-/*
- * Some keyboards have a buildin LCD panel where the contents are controlled
- * by the host. Often these have a number of keys directly below the LCD
- * intended for controlling a menu shown on the LCD. These keys often don't
- * have any labeling so we just name them KEY_KBD_LCD_MENU#
- */
-#define KEY_KBD_LCD_MENU1		0x2b8
-#define KEY_KBD_LCD_MENU2		0x2b9
-#define KEY_KBD_LCD_MENU3		0x2ba
-#define KEY_KBD_LCD_MENU4		0x2bb
-#define KEY_KBD_LCD_MENU5		0x2bc
-
-#define BTN_TRIGGER_HAPPY		0x2c0
-#define BTN_TRIGGER_HAPPY1		0x2c0
-#define BTN_TRIGGER_HAPPY2		0x2c1
-#define BTN_TRIGGER_HAPPY3		0x2c2
-#define BTN_TRIGGER_HAPPY4		0x2c3
-#define BTN_TRIGGER_HAPPY5		0x2c4
-#define BTN_TRIGGER_HAPPY6		0x2c5
-#define BTN_TRIGGER_HAPPY7		0x2c6
-#define BTN_TRIGGER_HAPPY8		0x2c7
-#define BTN_TRIGGER_HAPPY9		0x2c8
-#define BTN_TRIGGER_HAPPY10		0x2c9
-#define BTN_TRIGGER_HAPPY11		0x2ca
-#define BTN_TRIGGER_HAPPY12		0x2cb
-#define BTN_TRIGGER_HAPPY13		0x2cc
-#define BTN_TRIGGER_HAPPY14		0x2cd
-#define BTN_TRIGGER_HAPPY15		0x2ce
-#define BTN_TRIGGER_HAPPY16		0x2cf
-#define BTN_TRIGGER_HAPPY17		0x2d0
-#define BTN_TRIGGER_HAPPY18		0x2d1
-#define BTN_TRIGGER_HAPPY19		0x2d2
-#define BTN_TRIGGER_HAPPY20		0x2d3
-#define BTN_TRIGGER_HAPPY21		0x2d4
-#define BTN_TRIGGER_HAPPY22		0x2d5
-#define BTN_TRIGGER_HAPPY23		0x2d6
-#define BTN_TRIGGER_HAPPY24		0x2d7
-#define BTN_TRIGGER_HAPPY25		0x2d8
-#define BTN_TRIGGER_HAPPY26		0x2d9
-#define BTN_TRIGGER_HAPPY27		0x2da
-#define BTN_TRIGGER_HAPPY28		0x2db
-#define BTN_TRIGGER_HAPPY29		0x2dc
-#define BTN_TRIGGER_HAPPY30		0x2dd
-#define BTN_TRIGGER_HAPPY31		0x2de
-#define BTN_TRIGGER_HAPPY32		0x2df
-#define BTN_TRIGGER_HAPPY33		0x2e0
-#define BTN_TRIGGER_HAPPY34		0x2e1
-#define BTN_TRIGGER_HAPPY35		0x2e2
-#define BTN_TRIGGER_HAPPY36		0x2e3
-#define BTN_TRIGGER_HAPPY37		0x2e4
-#define BTN_TRIGGER_HAPPY38		0x2e5
-#define BTN_TRIGGER_HAPPY39		0x2e6
-#define BTN_TRIGGER_HAPPY40		0x2e7
-
-/* We avoid low common keys in module aliases so they don't get huge. */
-#define KEY_MIN_INTERESTING	KEY_MUTE
-#define KEY_MAX			0x2ff
-#define KEY_CNT			(KEY_MAX+1)
-
-/*
- * Relative axes
- */
-
-#define REL_X			0x00
-#define REL_Y			0x01
-#define REL_Z			0x02
-#define REL_RX			0x03
-#define REL_RY			0x04
-#define REL_RZ			0x05
-#define REL_HWHEEL		0x06
-#define REL_DIAL		0x07
-#define REL_WHEEL		0x08
-#define REL_MISC		0x09
-/*
- * 0x0a is reserved and should not be used in input drivers.
- * It was used by HID as REL_MISC+1 and userspace needs to detect if
- * the next REL_* event is correct or is just REL_MISC + n.
- * We define here REL_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define REL_RESERVED		0x0a
-#define REL_WHEEL_HI_RES	0x0b
-#define REL_HWHEEL_HI_RES	0x0c
-#define REL_MAX			0x0f
-#define REL_CNT			(REL_MAX+1)
-
-/*
- * Absolute axes
- */
-
-#define ABS_X			0x00
-#define ABS_Y			0x01
-#define ABS_Z			0x02
-#define ABS_RX			0x03
-#define ABS_RY			0x04
-#define ABS_RZ			0x05
-#define ABS_THROTTLE		0x06
-#define ABS_RUDDER		0x07
-#define ABS_WHEEL		0x08
-#define ABS_GAS			0x09
-#define ABS_BRAKE		0x0a
-#define ABS_HAT0X		0x10
-#define ABS_HAT0Y		0x11
-#define ABS_HAT1X		0x12
-#define ABS_HAT1Y		0x13
-#define ABS_HAT2X		0x14
-#define ABS_HAT2Y		0x15
-#define ABS_HAT3X		0x16
-#define ABS_HAT3Y		0x17
-#define ABS_PRESSURE		0x18
-#define ABS_DISTANCE		0x19
-#define ABS_TILT_X		0x1a
-#define ABS_TILT_Y		0x1b
-#define ABS_TOOL_WIDTH		0x1c
-
-#define ABS_VOLUME		0x20
-
-#define ABS_MISC		0x28
-
-/*
- * 0x2e is reserved and should not be used in input drivers.
- * It was used by HID as ABS_MISC+6 and userspace needs to detect if
- * the next ABS_* event is correct or is just ABS_MISC + n.
- * We define here ABS_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define ABS_RESERVED		0x2e
-
-#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
-#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
-#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
-#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
-#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
-#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
-#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
-#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
-#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
-#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
-#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
-#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
-#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
-#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
-#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
-
-
-#define ABS_MAX			0x3f
-#define ABS_CNT			(ABS_MAX+1)
-
-/*
- * Switch events
- */
-
-#define SW_LID			0x00  /* set = lid shut */
-#define SW_TABLET_MODE		0x01  /* set = tablet mode */
-#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
-#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
-					 set = radio enabled */
-#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
-#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
-#define SW_DOCK			0x05  /* set = plugged into dock */
-#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
-#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
-#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
-#define SW_CAMERA_LENS_COVER	0x09  /* set = lens covered */
-#define SW_KEYPAD_SLIDE		0x0a  /* set = keypad slide out */
-#define SW_FRONT_PROXIMITY	0x0b  /* set = front proximity sensor active */
-#define SW_ROTATE_LOCK		0x0c  /* set = rotate locked/disabled */
-#define SW_LINEIN_INSERT	0x0d  /* set = inserted */
-#define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
-#define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
-#define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_MAX			0x10
-#define SW_CNT			(SW_MAX+1)
-
-/*
- * Misc events
- */
-
-#define MSC_SERIAL		0x00
-#define MSC_PULSELED		0x01
-#define MSC_GESTURE		0x02
-#define MSC_RAW			0x03
-#define MSC_SCAN		0x04
-#define MSC_TIMESTAMP		0x05
-#define MSC_MAX			0x07
-#define MSC_CNT			(MSC_MAX+1)
-
-/*
- * LEDs
- */
-
-#define LED_NUML		0x00
-#define LED_CAPSL		0x01
-#define LED_SCROLLL		0x02
-#define LED_COMPOSE		0x03
-#define LED_KANA		0x04
-#define LED_SLEEP		0x05
-#define LED_SUSPEND		0x06
-#define LED_MUTE		0x07
-#define LED_MISC		0x08
-#define LED_MAIL		0x09
-#define LED_CHARGING		0x0a
-#define LED_MAX			0x0f
-#define LED_CNT			(LED_MAX+1)
-
-/*
- * Autorepeat values
- */
-
-#define REP_DELAY		0x00
-#define REP_PERIOD		0x01
-#define REP_MAX			0x01
-#define REP_CNT			(REP_MAX+1)
-
-/*
- * Sounds
- */
-
-#define SND_CLICK		0x00
-#define SND_BELL		0x01
-#define SND_TONE		0x02
-#define SND_MAX			0x07
-#define SND_CNT			(SND_MAX+1)
-
-#endif
diff -Naur old/src/evdev-fallback.c new/src/evdev-fallback.c
--- old/src/evdev-fallback.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-fallback.c	2021-01-01 00:00:00.000000000 +0800
@@ -689,26 +689,9 @@
 
 	if (event->type != LIBINPUT_EVENT_KEYBOARD_KEY)
 		return;
-
-	if (dispatch->lid.reliability == RELIABILITY_WRITE_OPEN) {
-		int fd = libevdev_get_fd(dispatch->device->evdev);
-		int rc;
-		struct input_event ev[2];
-
-		ev[0] = input_event_init(0, EV_SW, SW_LID, 0);
-		ev[1] = input_event_init(0, EV_SYN, SYN_REPORT, 0);
-
-		rc = write(fd, ev, sizeof(ev));
-
-		if (rc < 0)
-			evdev_log_error(dispatch->device,
-					"failed to write SW_LID state (%s)",
-					strerror(errno));
-
-		/* In case write() fails, we sync the lid state manually
-		 * regardless. */
-	}
-
+    
+    // hdf has no write fd operation.
+    
 	/* Posting the event here means we preempt the keyboard events that
 	 * caused us to wake up, so the lid event is always passed on before
 	 * the key event.
@@ -1031,6 +1014,9 @@
 	if (dispatch->arbitration.in_arbitration)
 		return;
 
+	libinput_log_printf("1.event divice_name:%s divice_fd:%d type:%d code:%d value:%d  time:%llu  curtime:%llu \r\n",
+        device->devname, device->fd, event->type, event->code, event->value, getTranTime(event), getMicrotime());
+
 	switch (event->type) {
 	case EV_REL:
 		fallback_process_relative(dispatch, device, event, time);
@@ -1575,7 +1561,7 @@
 	   Devices with ABS_MT_POSITION_* but not ABS_MT_SLOT
 	   require mtdev for conversion. */
 	if (evdev_need_mtdev(device)) {
-		device->mtdev = mtdev_new_open(device->fd);
+		device->mtdev = mtdev_new_open_hdi(device->uhdf->index,device->uhdf->fn);
 		if (!device->mtdev)
 			return -1;
 
diff -Naur old/src/evdev-fallback.h new/src/evdev-fallback.h
--- old/src/evdev-fallback.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-fallback.h	2021-01-01 00:00:00.000000000 +0800
@@ -169,6 +169,7 @@
 static inline enum key_type
 get_key_type(uint16_t code)
 {
+	const uint16_t KEY_ENDCALL = 0x2e8;
 	switch (code) {
 	case BTN_TOOL_PEN:
 	case BTN_TOOL_RUBBER:
@@ -198,6 +199,8 @@
 		return KEY_TYPE_KEY;
 	if (code >= BTN_TRIGGER_HAPPY && code <= BTN_TRIGGER_HAPPY40)
 		return KEY_TYPE_BUTTON;
+	if (code == KEY_ENDCALL)
+		return KEY_TYPE_KEY;
 	return KEY_TYPE_NONE;
 }
 
diff -Naur old/src/evdev-joystick.c new/src/evdev-joystick.c
--- old/src/evdev-joystick.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-joystick.c	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,583 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <string.h>
+
+#include "config.h"
+#include "libinput-version.h"
+#include "evdev-joystick.h"
+#include "input-event-codes.h"
+#include "libinput.h"
+#include "libinput-util.h"
+
+static inline struct
+joystick_dispatch* get_joystick_dispatch(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return NULL;
+    }
+    evdev_verify_dispatch_type(dispatch, DISPATCH_JOYSTICK);
+
+    struct joystick_dispatch* joystick_dispatch = NULL;
+    joystick_dispatch = container_of(dispatch, struct joystick_dispatch, base);
+
+    return joystick_dispatch;
+}
+
+static int
+update_seat_joystick_button_count(struct libinput_seat* pSeat, int32_t key, uint32_t *pRetcount, enum libinput_key_state state)
+{
+    if (pSeat == NULL || pRetcount == NULL || key < SYN_REPORT || key > KEY_MAX) {
+        return false;
+    }
+
+    switch (state) {
+        case LIBINPUT_KEY_STATE_PRESSED:
+        {
+            *(pRetcount) = ++pSeat->button_count[key];
+        }
+        break;
+        case LIBINPUT_KEY_STATE_RELEASED:
+        {
+            if (pSeat->button_count[key] == 0) {
+                *(pRetcount) = pSeat->button_count[key];
+            }
+            else {
+                *(pRetcount) = --pSeat->button_count[key];
+            }
+        }
+        break;
+        default:
+            *(pRetcount) = 0;
+            break;
+    }
+    return true;
+}
+
+static void
+joystick_notify_axis(struct evdev_device* device, uint64_t time)
+{
+    if (device == NULL) {
+        return;
+    }
+
+	struct joystick_dispatch *joystick_dispatch = get_joystick_dispatch(device->dispatch);
+	if (joystick_dispatch == NULL) {
+        libinput_log_printf("joystick_dispatch is NULL.\n");
+		return;
+	}
+
+    struct libinput_event_joystick_axis* joystick_axis_event = zalloc(sizeof * joystick_axis_event);
+    if (joystick_axis_event == NULL) {
+        libinput_log_printf("pJoystickEvent is NULL.\n");
+        return;
+    }
+
+    *joystick_axis_event = (struct libinput_event_joystick_axis){
+	    .base.type = LIBINPUT_EVENT_POINTER_AXIS,
+	    .base.device = &device->base,
+        .type = EV_ABS,
+        .time = time,
+        .axis_value_mask = joystick_dispatch->axis_value_mask,
+	    .abs_throttle = joystick_dispatch->abs_throttle,
+	    .abs_hat0x = joystick_dispatch->abs_hat0x,
+	    .abs_hat0y = joystick_dispatch->abs_hat0y,
+	    .abs_x = joystick_dispatch->abs_x,
+		.abs_y = joystick_dispatch->abs_y,
+		.abs_z = joystick_dispatch->abs_z,
+		.abs_rx = joystick_dispatch->abs_rx,
+		.abs_ry = joystick_dispatch->abs_ry,
+		.abs_rz = joystick_dispatch->abs_rz,
+    };
+
+    struct libinput_event_listener* listener = NULL;
+    struct libinput_event_listener* tmp_listener = NULL;
+    list_for_each_safe(listener, tmp_listener, &device->base.event_listeners, link) {
+        listener->notify_func(time, &joystick_axis_event->base, listener->notify_func_data);
+    }
+
+    libinput_post_handle_event(device->base.seat->libinput, &joystick_axis_event->base);
+}
+
+static void
+joystick_notify_key_event(struct evdev_device* device, struct input_event* pEvent, uint64_t time)
+{
+    if (device == NULL || pEvent == NULL) {
+        return;
+    }
+
+    struct libinput_event_joystick_button* pKeyEvent = {0};
+    uint32_t uiSeatCount = 0;
+
+    int iRet = update_seat_joystick_button_count(device->base.seat, pEvent->code, &uiSeatCount, pEvent->value);
+    if (iRet == false) {
+        return;
+    }
+
+    pKeyEvent = zalloc(sizeof * pKeyEvent);
+    if (pKeyEvent == NULL) {
+        return;
+    }
+
+	*pKeyEvent = (struct libinput_event_joystick_button) {
+			.base.type = LIBINPUT_EVENT_POINTER_BUTTON,
+			.base.device = &device->base,
+            .time = time,
+            .type = pEvent->type,
+            .key = pEvent->code,
+            .value = pEvent->value,
+            .seat_key_count = uiSeatCount,
+            .state = pEvent->value,
+    };
+
+    struct libinput_event_listener* listener = NULL;
+    struct libinput_event_listener* tmp_listener = NULL;
+    list_for_each_safe(listener, tmp_listener, &device->base.event_listeners, link)
+    {
+        listener->notify_func(time, &pKeyEvent->base, listener->notify_func_data);
+    }
+
+    libinput_post_handle_event(device->base.seat->libinput, &pKeyEvent->base);
+}
+
+static float
+abs_value_standardize(int32_t value, int32_t minimum, int32_t maximum, float standard_min, float standard_max)
+{
+    return standard_min + ((float)value - (float)minimum) * ((float)(standard_max - standard_min)) / ((float)(maximum - minimum));
+}
+
+static float
+get_joystick_abs_standard_value(struct libinput_event_joystick_axis_abs_info *absinfo)
+{
+    const int32_t value = absinfo->value;
+    const int32_t minimum = absinfo->minimum;
+    const int32_t maximum = absinfo->maximum;
+    if (minimum >= maximum) {
+		libinput_log_printf("joystick abs: minimum(%u) >= maximum(%u).\n", minimum, maximum);
+        return 0.f;
+    } else if (value < minimum || value > maximum) {
+		libinput_log_printf("joystick abs: value(%d) not between minimum(%u) and maximum(%u).\n", value, minimum, maximum);
+		return 0.f;
+    }
+
+    const int32_t code = absinfo->code;
+    switch (code) {
+	case ABS_THROTTLE:
+	{
+		return abs_value_standardize(value, minimum, maximum, 0, 1.0);
+	}
+	case ABS_X:
+	case ABS_Y:
+	case ABS_Z:
+	case ABS_RX:
+	case ABS_RY:
+	case ABS_RZ:
+    {
+        return abs_value_standardize(value, minimum, maximum, -1.0, 1.0);
+	}
+    case ABS_HAT0X:
+    case ABS_HAT0Y:
+    {
+        return (float)value;
+    }
+    default:
+    return (float)value;
+    }
+}
+
+static void joystick_set_axis_value_mask(struct joystick_dispatch *joystick_dispatch, enum libinput_joystick_axis_source axis)
+{
+    joystick_dispatch->axis_value_mask |= (uint32_t)axis;
+}
+
+static void joystick_reset_axis_value_mask(struct joystick_dispatch *joystick_dispatch)
+{
+	joystick_dispatch->axis_value_mask = 0;
+}
+
+static bool joystick_is_axis_value_mask(struct joystick_dispatch *joystick_dispatch)
+{
+	return (joystick_dispatch->axis_value_mask != 0);
+}
+
+static void joystick_get_one_abs_info(struct joystick_dispatch *joystick_dispatch, struct evdev_device *device, struct input_event *event,
+    const uint32_t code)
+{
+    struct libinput_event_joystick_axis_abs_info *absinfo = NULL;
+    switch (code) {
+    case ABS_THROTTLE:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE);
+    absinfo = &joystick_dispatch->abs_throttle;
+    break;
+    case ABS_HAT0X:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X);
+    absinfo = &joystick_dispatch->abs_hat0x;
+    break;
+    case ABS_HAT0Y:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y);
+    absinfo = &joystick_dispatch->abs_hat0y;
+    break;
+    case ABS_X:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X);
+    absinfo = &joystick_dispatch->abs_x;
+    break;
+    case ABS_Y:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y);
+    absinfo = &joystick_dispatch->abs_y;
+    break;
+	case ABS_Z:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z);
+	absinfo = &joystick_dispatch->abs_z;
+    break;
+	case ABS_RX:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX);
+	absinfo = &joystick_dispatch->abs_rx;
+	break;
+	case ABS_RY:
+	joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY);
+	absinfo = &joystick_dispatch->abs_ry;
+	break;
+    case ABS_RZ:
+    joystick_set_axis_value_mask(joystick_dispatch, LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ);
+    absinfo = &joystick_dispatch->abs_rz;
+    break;
+    default:
+    break;
+    }
+
+    if (absinfo == NULL) {
+        libinput_log_printf("unsupported joystick abs event: divice_name:%s code:%d value:%d.\n",
+            device->devname, code, event->value);
+        return;
+    }
+
+    struct libevdev *evdev = device->evdev;
+    evdev_device_check_abs_axis_range(device, event->code, event->value);
+    const struct input_absinfo *absinfo_raw = libevdev_get_abs_info(evdev, event->code);
+    absinfo->code = event->code;
+    absinfo->value = event->value;
+    absinfo->minimum = absinfo_raw->minimum;
+    absinfo->maximum = absinfo_raw->maximum;
+    absinfo->fuzz = absinfo_raw->fuzz;
+    absinfo->flat = absinfo_raw->flat;
+    absinfo->resolution = absinfo_raw->resolution;
+    absinfo->standardValue = get_joystick_abs_standard_value(absinfo);
+}
+
+static void
+joystick_notify_absolute_event(struct joystick_dispatch* pJoystick,
+    struct evdev_device* device, struct input_event* event, uint64_t time)
+{
+    if (pJoystick == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    joystick_get_one_abs_info(pJoystick, device, event, event->code);
+}
+
+static void
+joystick_flush(struct joystick_dispatch* joystick_dispatch, struct evdev_device* device, uint64_t time)
+{
+    if (joystick_dispatch == NULL || device == NULL) {
+        return;
+    }
+
+    if (joystick_dispatch->axis_value_mask != 0) {
+        joystick_notify_axis(device, time);
+        joystick_reset_axis_value_mask(joystick_dispatch);
+    }
+}
+
+static void
+joystick_process(struct evdev_dispatch* dispatch, struct evdev_device* device,
+    struct input_event* event, uint64_t time)
+{
+    if (dispatch == NULL || device == NULL || event == NULL) {
+        return;
+    }
+
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    libinput_log_printf("1.event divice_name:%s divice_fd:%d type:%d code:%d value:%d  time:%llu  curtime:%llu\r\n",
+            device->devname, device->fd, event->type, event->code, event->value, getTranTime(event), getMicrotime());
+
+    switch (event->type) {
+    case EV_ABS: {
+        joystick_notify_absolute_event(joystick_dispatch, device, event, time);
+    }
+    break;
+    case EV_KEY: {
+        joystick_notify_key_event(device, event, time);
+    }
+    break;
+    case EV_SYN: {
+        joystick_flush(joystick_dispatch, device, time);
+    }
+    break;
+    case EV_MSC:
+    /* ignore do not process */
+    break;
+    case EV_REL:
+    case EV_SW:
+    case EV_LED:
+    case EV_SND:
+    case EV_REP:
+    case EV_FF:
+    case EV_PWR:
+    case EV_FF_STATUS:
+    case EV_MAX:
+    case EV_CNT:
+    default:
+        libinput_log_printf("unsupported joystick event type: %d, devname: %s.\n", event->type, device->devname);
+    break;
+    }
+}
+
+static void joystick_suspend(struct evdev_dispatch* dispatch, struct evdev_device* device)
+{
+    if (dispatch == NULL || device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+   joystick_flush(joystick_dispatch, device, 0);
+}
+
+static void
+joystick_destroy(struct evdev_dispatch* dispatch)
+{
+    if (dispatch == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(dispatch);
+    if (dispatch == NULL) {
+        return;
+    }
+
+    free(joystick_dispatch);
+}
+
+static void
+joystick_device_added(struct evdev_device* device,
+    struct evdev_device* added_device)
+{
+    if (device == NULL || added_device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(device->dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    bool is_joystick = false;
+    if (libinput_device_get_device_group(&device->base) !=
+        libinput_device_get_device_group(&added_device->base)) {
+        return;
+    }
+    is_joystick = evdev_device_has_capability(added_device,
+        LIBINPUT_DEVICE_CAP_JOYSTICK);
+
+    if (is_joystick) {
+        evdev_log_debug(device,
+            "joystick: activated for %s<->%s\n",
+            device->devname,
+            added_device->devname);
+        joystick_dispatch->device = added_device;
+    }
+}
+
+static void
+joystick_device_removed(struct evdev_device* device,
+    struct evdev_device* removed_device)
+{
+    if (device == NULL || removed_device == NULL) {
+        return;
+    }
+    struct joystick_dispatch* joystick_dispatch = get_joystick_dispatch(device->dispatch);
+    if (joystick_dispatch == NULL) {
+        return;
+    }
+
+    if (joystick_dispatch->device == removed_device) {
+        joystick_dispatch->device = NULL;
+    }
+}
+
+static struct evdev_dispatch_interface joystick_interface = {
+    .process = joystick_process,
+    .suspend = joystick_suspend,
+    .remove = NULL,
+    .destroy = joystick_destroy,
+    .device_added = joystick_device_added,
+    .device_removed = joystick_device_removed,
+    .device_suspended = NULL,
+    .device_resumed = NULL,
+    .post_added = NULL,
+    .touch_arbitration_toggle = NULL,
+    .touch_arbitration_update_rect = NULL,
+    .get_switch_state = NULL,
+};
+
+static enum libinput_config_status
+joystick_sendevents_set_mode(struct libinput_device* device,
+    enum libinput_config_send_events_mode mode)
+{
+    if (device == NULL)     {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct joystick_dispatch* joystick_dispatch = (struct joystick_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || joystick_dispatch == NULL) {
+        return LIBINPUT_CONFIG_STATUS_INVALID;
+    }
+
+    if (mode == joystick_dispatch->sendevents.current_mode) {
+        return LIBINPUT_CONFIG_STATUS_SUCCESS;
+    }
+        
+    switch (mode) {
+    case LIBINPUT_CONFIG_SEND_EVENTS_ENABLED:
+        break;
+    case LIBINPUT_CONFIG_SEND_EVENTS_DISABLED:
+        joystick_suspend(ev_device->dispatch, ev_device);
+        break;
+    default:
+        return LIBINPUT_CONFIG_STATUS_UNSUPPORTED;
+    }
+
+    joystick_dispatch->sendevents.current_mode = mode;
+
+    return LIBINPUT_CONFIG_STATUS_SUCCESS;
+}
+
+static uint32_t
+joystick_sendevents_get_modes(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+}
+
+static enum libinput_config_send_events_mode
+joystick_sendevents_get_mode(struct libinput_device* device)
+{
+    if (device == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    struct evdev_device* ev_device = evdev_device(device);
+    struct joystick_dispatch* pDispatch = (struct joystick_dispatch*)ev_device->dispatch;
+
+    if (ev_device == NULL || pDispatch == NULL) {
+        return LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
+    }
+
+    return pDispatch->sendevents.current_mode;
+}
+
+static enum libinput_config_send_events_mode
+joystick_sendevents_get_default_mode(struct libinput_device* device)
+{
+    return LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+}
+
+#ifdef _DEBUG
+void printf_joystick_absinfo(const char *abs_name, struct libinput_event_joystick_axis_abs_info *absinfo)
+{
+    printf("%s: code: %d, value: %d, minimum: %d, maximum: %d, fuzz: %d, flat: %d, resolution: %d, standardValue: %f\n",
+        abs_name,
+        absinfo->code,
+        absinfo->value,
+        absinfo->minimum,
+        absinfo->maximum,
+        absinfo->fuzz,
+        absinfo->flat,
+        absinfo->resolution,
+        absinfo->standardValue
+        );
+}
+
+void print_libinput_event_joystick_axis(struct libinput_event_joystick_axis *p)
+{
+    printf("JOYSTICK:\n"
+        "type: %d, device: %p, type: %d, time: 0x%x\n",
+        p->base.type,
+        p->base.device,
+        p->type,
+        p->time);
+    printf_joystick_absinfo("abs_throttle", &p->abs_throttle);
+    printf_joystick_absinfo("abs_hat0x", &p->abs_hat0x);
+    printf_joystick_absinfo("abs_hat0y", &p->abs_hat0y);
+    printf_joystick_absinfo("abs_x", &p->abs_x);
+	printf_joystick_absinfo("abs_y", &p->abs_y);
+	printf_joystick_absinfo("abs_z", &p->abs_z);
+	printf_joystick_absinfo("abs_rx", &p->abs_rx);
+	printf_joystick_absinfo("abs_ry", &p->abs_ry);
+    printf_joystick_absinfo("abs_rz", &p->abs_rz);
+}
+#endif // _DEBUG
+
+/**
+ * @brief 初始化joystick_dispatch
+ * @param joystick 
+ * @param device 
+ * @return bool true - 成功, false - 失败
+*/
+bool
+joystick_init(struct joystick_dispatch* pJoystick, struct evdev_device* device)
+{
+    if (pJoystick == NULL || device == NULL) {
+        return false;
+    }
+
+    pJoystick->base.dispatch_type = DISPATCH_JOYSTICK;
+    pJoystick->base.interface = &joystick_interface;
+    pJoystick->device = device;
+
+    return true;
+}
+
+struct evdev_dispatch*
+evdev_joystick_create(struct evdev_device* device)
+{
+    if (device == NULL) {
+        return NULL;
+    }
+
+    struct joystick_dispatch* joystick = {0};
+    joystick = zalloc(sizeof * joystick);
+
+    if (joystick_init(joystick, device) != true) {
+        joystick_destroy(&joystick->base);
+        joystick = NULL;
+        return NULL;
+    }
+
+    device->base.config.sendevents = &joystick->sendevents.config;
+    joystick->sendevents.current_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
+    joystick->sendevents.config.get_modes = joystick_sendevents_get_modes;
+    joystick->sendevents.config.set_mode = joystick_sendevents_set_mode;
+    joystick->sendevents.config.get_mode = joystick_sendevents_get_mode;
+    joystick->sendevents.config.get_default_mode = joystick_sendevents_get_default_mode;
+
+    return &joystick->base;
+}
+
diff -Naur old/src/evdev-joystick.h new/src/evdev-joystick.h
--- old/src/evdev-joystick.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/evdev-joystick.h	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef LIBINPUT_EVDEV_JOYSTICK_H
+#define LIBINPUT_EVDEV_JOYSTICK_H
+
+#include "evdev.h"
+#include "libinput-private.h"
+
+struct joystick_dispatch {
+	struct evdev_dispatch base;
+	struct evdev_device* device;
+	uint32_t axis_value_mask;
+	struct libinput_event_joystick_axis_abs_info abs_throttle;
+	struct libinput_event_joystick_axis_abs_info abs_hat0x;
+	struct libinput_event_joystick_axis_abs_info abs_hat0y;
+	struct libinput_event_joystick_axis_abs_info abs_x;
+	struct libinput_event_joystick_axis_abs_info abs_y;
+	struct libinput_event_joystick_axis_abs_info abs_z;
+	struct libinput_event_joystick_axis_abs_info abs_rx;
+	struct libinput_event_joystick_axis_abs_info abs_ry;
+	struct libinput_event_joystick_axis_abs_info abs_rz;
+	struct {
+		struct libinput_device_config_send_events config;
+		enum libinput_config_send_events_mode current_mode;
+	} sendevents;
+};
+
+struct libinput_event_joystick_button {
+	struct libinput_event base;
+	uint32_t type;
+	uint64_t time;
+	uint32_t key;
+	uint32_t seat_key_count;
+	enum libinput_key_state state;
+	int value;
+};
+
+struct libinput_event_joystick_axis {
+	struct libinput_event base;
+    uint32_t type;
+	uint64_t time;
+	uint32_t axis_value_mask;
+	struct libinput_event_joystick_axis_abs_info abs_throttle;
+	struct libinput_event_joystick_axis_abs_info abs_hat0x;
+	struct libinput_event_joystick_axis_abs_info abs_hat0y;
+	struct libinput_event_joystick_axis_abs_info abs_x;
+	struct libinput_event_joystick_axis_abs_info abs_y;
+	struct libinput_event_joystick_axis_abs_info abs_z;
+	struct libinput_event_joystick_axis_abs_info abs_rx;
+	struct libinput_event_joystick_axis_abs_info abs_ry;
+	struct libinput_event_joystick_axis_abs_info abs_rz;
+};
+
+#ifdef _DEBUG
+void print_libinput_event_joystick_axis(struct libinput_event_joystick_axis* p);
+#endif // _DEBUG
+
+/**
+ * @brief 创建evdev_dispatch结构体
+ * @param device 
+ * @return struct evdev_dispatch*
+*/
+struct evdev_dispatch* evdev_joystick_create(struct evdev_device* device);
+
+#endif
diff -Naur old/src/evdev-mt-touchpad-gestures.c new/src/evdev-mt-touchpad-gestures.c
--- old/src/evdev-mt-touchpad-gestures.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad-gestures.c	2021-01-01 00:00:00.000000000 +0800
@@ -80,6 +80,37 @@
 }
 
 static void
+tp_get_raw_touches(struct tp_dispatch *tp, struct sloted_coords_info *raw_touches)
+{
+	struct tp_touch *t;
+	unsigned int i;
+	raw_touches->active_count = 0;
+
+	if (tp->num_slots > MAX_SOLTED_COORDS_NUM) {
+		evdev_log_bug_libinput(tp->device,
+				       "in %s, num_slots: %d, more than %d\n",
+				       __func__, tp->num_slots, MAX_SOLTED_COORDS_NUM);
+	}
+	const unsigned int num_slots = (tp->num_slots > MAX_SOLTED_COORDS_NUM) ? MAX_SOLTED_COORDS_NUM : tp->num_slots;
+
+	for (i = 0; i < num_slots; i++) {
+		t = &tp->touches[i];
+
+		if (!tp_touch_active_for_gesture(tp, t))
+			continue;
+
+		if (t->dirty) {
+			struct device_coords d;
+			d = tp_get_delta(t);
+			raw_touches->coords[i].x = d.x;
+			raw_touches->coords[i].y = d.y;
+		}
+		raw_touches->coords[i].is_active = true;
+		raw_touches->active_count++;
+	}
+}
+
+static void
 tp_gesture_init_scroll(struct tp_dispatch *tp)
 {
 	struct phys_coords zero = {0.0, 0.0};
@@ -131,7 +162,7 @@
 		gesture_notify_swipe(&tp->device->base, time,
 				     LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN,
 				     tp->gesture.finger_count,
-				     &zero, &zero);
+				     &zero, &zero, NULL);
 		break;
 	}
 
@@ -630,10 +661,12 @@
 tp_gesture_handle_state_swipe(struct tp_dispatch *tp, uint64_t time)
 {
 	struct device_float_coords raw;
+	struct sloted_coords_info raw_touches = {};
 	struct normalized_coords delta, unaccel;
 
 	raw = tp_get_average_touches_delta(tp);
 	delta = tp_filter_motion(tp, &raw, time);
+	tp_get_raw_touches(tp, &raw_touches);
 
 	if (!normalized_is_zero(delta) || !device_float_is_zero(raw)) {
 		unaccel = tp_normalize_delta(tp, raw);
@@ -641,7 +674,7 @@
 		gesture_notify_swipe(&tp->device->base, time,
 				     LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE,
 				     tp->gesture.finger_count,
-				     &delta, &unaccel);
+				     &delta, &unaccel, &raw_touches);
 	}
 
 	return GESTURE_STATE_SWIPE;
diff -Naur old/src/evdev-mt-touchpad-thumb.c new/src/evdev-mt-touchpad-thumb.c
--- old/src/evdev-mt-touchpad-thumb.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad-thumb.c	2021-01-01 00:00:00.000000000 +0800
@@ -418,7 +418,7 @@
 	tp->thumb.lower_thumb_line = edges.y;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 
 	if (libevdev_has_event_code(device->evdev, EV_ABS, ABS_MT_PRESSURE)) {
 		if (quirks_get_uint32(q,
diff -Naur old/src/evdev-mt-touchpad.c new/src/evdev-mt-touchpad.c
--- old/src/evdev-mt-touchpad.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-mt-touchpad.c	2021-01-01 00:00:00.000000000 +0800
@@ -1936,6 +1936,9 @@
 		     uint64_t time)
 {
 	struct tp_dispatch *tp = tp_dispatch(dispatch);
+	
+	libinput_log_printf("1.event divice_name:%s divice_fd:%d type:%d code:%d value:%d  time:%llu curtime:%llu\r\n",
+		device->devname, device->fd, e->type, e->code, e->value, getTranTime(e), getMicrotime());
 
 	switch (e->type) {
 	case EV_ABS:
@@ -2686,12 +2689,12 @@
 
 static void
 evdev_tag_touchpad(struct evdev_device *device,
-		   struct udev_device *udev_device)
+           struct uhdf *uhdf )
 {
 	int bustype, vendor;
 	const char *prop;
 
-	prop = udev_device_get_property_value(udev_device,
+	prop = uhdf_device_get_property_value(uhdf,
 					      "ID_INPUT_TOUCHPAD_INTEGRATION");
 	if (prop) {
 		if (streq(prop, "internal")) {
@@ -3197,7 +3200,7 @@
 	int rc = false;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (!q)
 		return false;
 
@@ -3281,7 +3284,7 @@
 	struct quirks *q;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (!q)
 		return threshold;
 
@@ -3317,7 +3320,7 @@
 	uint32_t threshold;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (!q)
 		return;
 
@@ -3511,7 +3514,7 @@
 	assert(abs);
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (q && quirks_get_range(q, QUIRK_ATTR_PRESSURE_RANGE, &r)) {
 		hi = r.upper;
 		lo = r.lower;
@@ -3567,7 +3570,7 @@
 	}
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (q && quirks_get_range(q, QUIRK_ATTR_TOUCH_SIZE_RANGE, &r)) {
 		hi = r.upper;
 		lo = r.lower;
@@ -3839,7 +3842,7 @@
 {
 	struct tp_dispatch *tp;
 
-	evdev_tag_touchpad(device, device->udev_device);
+	evdev_tag_touchpad(device,device->uhdf);
 
 	tp = zalloc(sizeof *tp);
 
diff -Naur old/src/evdev-tablet-pad-leds.c new/src/evdev-tablet-pad-leds.c
--- old/src/evdev-tablet-pad-leds.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-tablet-pad-leds.c	2021-01-01 00:00:00.000000000 +0800
@@ -186,7 +186,7 @@
 static inline bool
 is_litest_device(struct evdev_device *device)
 {
-	return !!udev_device_get_property_value(device->udev_device,
+	return !!uhdf_device_get_property_value(device->uhdf,
 						"LIBINPUT_TEST_DEVICE");
 }
 
@@ -239,34 +239,7 @@
 			    char *path_out,
 			    size_t path_out_sz)
 {
-	struct udev_device *parent, *udev_device;
-	const char *test_path;
-	int rc;
-
-	udev_device = device->udev_device;
-
-	/* For testing purposes only allow for a base path set through a
-	 * udev rule. We still expect the normal directory hierarchy inside */
-	test_path = udev_device_get_property_value(udev_device,
-						   "LIBINPUT_TEST_TABLET_PAD_SYSFS_PATH");
-	if (test_path) {
-		rc = snprintf(path_out, path_out_sz, "%s", test_path);
-		return rc != -1;
-	}
-
-	parent = udev_device_get_parent_with_subsystem_devtype(udev_device,
-							       "input",
-							       NULL);
-	if (!parent)
-		return false;
-
-	rc = snprintf(path_out,
-		      path_out_sz,
-		      "%s/%s::wacom-",
-		      udev_device_get_syspath(parent),
-		      udev_device_get_sysname(parent));
-
-	return rc != -1;
+	return false;
 }
 
 #if HAVE_LIBWACOM
diff -Naur old/src/evdev-tablet-pad.c new/src/evdev-tablet-pad.c
--- old/src/evdev-tablet-pad.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-tablet-pad.c	2021-01-01 00:00:00.000000000 +0800
@@ -482,6 +482,9 @@
 {
 	struct pad_dispatch *pad = pad_dispatch(dispatch);
 
+	libinput_log_printf("1.event divice_name:%s divice_fd:%d type:%d code:%d value:%d  time:%llu  curtime:%llu\r\n",
+		device->devname, device->fd, e->type, e->code, e->value, getTranTime(e), getMicrotime());
+
 	switch (e->type) {
 	case EV_ABS:
 		pad_process_absolute(pad, device, e, time);
diff -Naur old/src/evdev-tablet.c new/src/evdev-tablet.c
--- old/src/evdev-tablet.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-tablet.c	2021-01-01 00:00:00.000000000 +0800
@@ -1089,7 +1089,7 @@
 		goto out;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 
 	tool->pressure_offset = pressure->minimum;
 
diff -Naur old/src/evdev-totem.c new/src/evdev-totem.c
--- old/src/evdev-totem.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev-totem.c	2021-01-01 00:00:00.000000000 +0800
@@ -520,6 +520,9 @@
 	enum totem_slot_state global_state;
 	bool enable_touch;
 
+	libinput_log_printf("1.event divice_name:%s divice_fd:%d type:%d code:%d value:%d  time:%llu  curtime:%llu\r\n",
+        device->devname, device->fd, e->type, e->code, e->value, getTranTime(e), getMicrotime());
+
 	switch(e->type) {
 	case EV_ABS:
 		totem_process_abs(totem, device, e, time);
diff -Naur old/src/evdev.c new/src/evdev.c
--- old/src/evdev.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev.c	2021-01-01 00:00:00.000000000 +0800
@@ -38,7 +38,7 @@
 #include <assert.h>
 #include <math.h>
 #include <stdint.h>
-
+#include <stdatomic.h>
 #include "libinput.h"
 #include "evdev.h"
 #include "filter.h"
@@ -54,25 +54,7 @@
 #define DEFAULT_BUTTON_SCROLL_TIMEOUT ms2us(200)
 #define MAX_RETRY_OPEN_DEVICE_COUNT 10
 
-enum evdev_device_udev_tags {
-        EVDEV_UDEV_TAG_INPUT		= bit(0),
-        EVDEV_UDEV_TAG_KEYBOARD		= bit(1),
-        EVDEV_UDEV_TAG_MOUSE		= bit(2),
-        EVDEV_UDEV_TAG_TOUCHPAD		= bit(3),
-        EVDEV_UDEV_TAG_TOUCHSCREEN	= bit(4),
-        EVDEV_UDEV_TAG_TABLET		= bit(5),
-        EVDEV_UDEV_TAG_JOYSTICK		= bit(6),
-        EVDEV_UDEV_TAG_ACCELEROMETER	= bit(7),
-        EVDEV_UDEV_TAG_TABLET_PAD	= bit(8),
-        EVDEV_UDEV_TAG_POINTINGSTICK	= bit(9),
-        EVDEV_UDEV_TAG_TRACKBALL	= bit(10),
-        EVDEV_UDEV_TAG_SWITCH		= bit(11),
-};
 
-struct evdev_udev_tag_match {
-	const char *name;
-	enum evdev_device_udev_tags tag;
-};
 
 static const struct evdev_udev_tag_match evdev_udev_tag_matches[] = {
 	{"ID_INPUT",			EVDEV_UDEV_TAG_INPUT},
@@ -90,14 +72,20 @@
 	{"ID_INPUT_SWITCH",		EVDEV_UDEV_TAG_SWITCH},
 };
 
+const char *  uhdf_device_get_property_value(struct uhdf *uhdf,
+						   const char *key)
+{
+    return NULL;
+}
+
 static inline bool
 parse_udev_flag(struct evdev_device *device,
-		struct udev_device *udev_device,
+		struct uhdf *uhdf,
 		const char *property)
 {
 	const char *val;
 
-	val = udev_device_get_property_value(udev_device, property);
+	val = uhdf_device_get_property_value(uhdf, property);
 	if (!val)
 		return false;
 
@@ -409,7 +397,7 @@
 
 static void
 evdev_tag_external_mouse(struct evdev_device *device,
-			 struct udev_device *udev_device)
+			 struct uhdf *uhdf)
 {
 	int bustype;
 
@@ -420,7 +408,7 @@
 
 static void
 evdev_tag_trackpoint(struct evdev_device *device,
-		     struct udev_device *udev_device)
+             struct uhdf *uhdf)
 {
 	struct quirks_context *quirks;
 	struct quirks *q;
@@ -428,13 +416,13 @@
 
 	if (!libevdev_has_property(device->evdev,
 				  INPUT_PROP_POINTING_STICK) &&
-	    !parse_udev_flag(device, udev_device, "ID_INPUT_POINTINGSTICK"))
+	    !parse_udev_flag(device, uhdf, "ID_INPUT_POINTINGSTICK"))
 		return;
 
 	device->tags |= EVDEV_TAG_TRACKPOINT;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (q && quirks_get_string(q, QUIRK_ATTR_TRACKPOINT_INTEGRATION, &prop)) {
 		if (streq(prop, "internal")) {
 			/* noop, this is the default anyway */
@@ -467,8 +455,7 @@
 }
 
 static void
-evdev_tag_keyboard(struct evdev_device *device,
-		   struct udev_device *udev_device)
+evdev_tag_keyboard(struct evdev_device *device)
 {
 	struct quirks_context *quirks;
 	struct quirks *q;
@@ -486,7 +473,7 @@
 	}
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (q && quirks_get_string(q, QUIRK_ATTR_KEYBOARD_INTEGRATION, &prop)) {
 		if (streq(prop, "internal")) {
 			evdev_tag_keyboard_internal(device);
@@ -918,7 +905,7 @@
 	char *prop;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (!q || !quirks_get_string(q, QUIRK_ATTR_LID_SWITCH_RELIABILITY, &prop)) {
 		r = RELIABILITY_UNKNOWN;
 	} else if (!parse_switch_reliability_property(prop, &r)) {
@@ -1003,6 +990,24 @@
 	}
 }
 
+void
+evdev_device_dispatch_two(struct evdev_device *device,
+			  struct input_event *ev)
+{
+	if (!device->mtdev) {
+		evdev_process_event(device, ev);
+	} else {
+		mtdev_put_event(device->mtdev, ev);
+		if (libevdev_event_is_code(ev, EV_SYN, SYN_REPORT)) {
+			while (!mtdev_empty(device->mtdev)) {
+				struct input_event e;
+				mtdev_get_event(device->mtdev, &e);
+				evdev_process_event(device, &e);
+			}
+		}
+	}
+}
+
 static int
 evdev_sync_device(struct evdev_device *device)
 {
@@ -1045,6 +1050,34 @@
 	}
 }
 
+void
+evdev_device_hdfdispatch(void *data)
+{
+	struct libinput *libinput = data; 
+	int len;
+    int readcount = 0;
+    struct input_event event[256];
+    int index = -1;
+    do {   
+        len = read(libinput->pipes[0], event, sizeof(event));
+        atomic_fetch_sub_explicit(&libinput->pipesbytes,len,memory_order_release);
+        if(len > 0 && len % sizeof(struct input_event) != 0) {
+            
+            return ;
+        }
+        if(len < 0){
+            break;
+        }
+		for(unsigned int i = 0;i<len/sizeof(struct input_event); i++) {
+            index = (event[i].type>>8)&0xff;
+            event[i].type = event[i].type&0xff;
+            libevdev_set_event_value(libinput->device[index]->evdev, event[i].type,event[i].code,event[i].value);
+            evdev_device_dispatch_one(libinput->device[index], &event[i]);
+        }
+        readcount =atomic_load_explicit(&libinput->pipesbytes,__ATOMIC_SEQ_CST);
+	} while (readcount > 0);
+}
+
 static void
 evdev_device_dispatch(void *data)
 {
@@ -1238,7 +1271,7 @@
 	int val;
 
 	*angle = DEFAULT_WHEEL_CLICK_ANGLE;
-	prop = udev_device_get_property_value(device->udev_device, prop);
+	prop = uhdf_device_get_property_value(device->uhdf, prop);
 	if (!prop)
 		return false;
 
@@ -1263,7 +1296,7 @@
 {
 	int val;
 
-	prop = udev_device_get_property_value(device->udev_device, prop);
+	prop = uhdf_device_get_property_value(device->uhdf, prop);
 	if (!prop)
 		return false;
 
@@ -1319,7 +1352,7 @@
 		return 1.0;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (q) {
 		quirks_get_double(q, QUIRK_ATTR_TRACKPOINT_MULTIPLIER, &multiplier);
 		quirks_unref(q);
@@ -1348,7 +1381,7 @@
 	bool use_velocity_averaging = false; /* default off unless we have quirk */
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (q) {
 		quirks_get_bool(q,
 				QUIRK_ATTR_USE_VELOCITY_AVERAGING,
@@ -1372,7 +1405,7 @@
 	if (device->tags & EVDEV_TAG_TRACKPOINT)
 		return DEFAULT_MOUSE_DPI;
 
-	mouse_dpi = udev_device_get_property_value(device->udev_device,
+	mouse_dpi = uhdf_device_get_property_value(device->uhdf,
 						   "MOUSE_DPI");
 	if (mouse_dpi) {
 		dpi = parse_mouse_dpi_property(mouse_dpi);
@@ -1416,7 +1449,7 @@
 	struct quirks *q;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 
 	while (q && m->quirk) {
 		bool is_set;
@@ -1445,7 +1478,7 @@
 	quirks_unref(q);
 
 	if (parse_udev_flag(device,
-			    device->udev_device,
+			    device->uhdf,
 			    "ID_INPUT_TRACKBALL")) {
 		evdev_log_debug(device, "tagged as trackball\n");
 		model_flags |= EVDEV_MODEL_TRACKBALL;
@@ -1457,13 +1490,13 @@
 	 * usage, so we need to keep this for backwards compat.
 	 */
 	if (parse_udev_flag(device,
-			    device->udev_device,
+			    device->uhdf,
 			    "LIBINPUT_MODEL_LENOVO_X220_TOUCHPAD_FW81")) {
 		evdev_log_debug(device, "tagged as trackball\n");
 		model_flags |= EVDEV_MODEL_LENOVO_X220_TOUCHPAD_FW81;
 	}
 
-	if (parse_udev_flag(device, device->udev_device,
+	if (parse_udev_flag(device, device->uhdf,
 			    "LIBINPUT_TEST_DEVICE")) {
 		evdev_log_debug(device, "is a test device\n");
 		model_flags |= EVDEV_MODEL_TEST_DEVICE;
@@ -1483,7 +1516,7 @@
 	bool rc = false;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (!q)
 		return false;
 
@@ -1509,7 +1542,7 @@
 	bool rc = false;
 
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (!q)
 		return false;
 
@@ -1572,21 +1605,17 @@
 
 static enum evdev_device_udev_tags
 evdev_device_get_udev_tags(struct evdev_device *device,
-			   struct udev_device *udev_device)
+			   struct uhdf *uhdf)
 {
+
 	enum evdev_device_udev_tags tags = 0;
-	int i;
 
-	for (i = 0; i < 2 && udev_device; i++) {
-		unsigned j;
-		for (j = 0; j < ARRAY_LENGTH(evdev_udev_tag_matches); j++) {
-			const struct evdev_udev_tag_match match = evdev_udev_tag_matches[j];
-			if (parse_udev_flag(device,
-					    udev_device,
-					    match.name))
-				tags |= match.tag;
-		}
-		udev_device = udev_device_get_parent(udev_device);
+	unsigned j;
+	for (j = 0; j < ARRAY_LENGTH(evdev_udev_tag_matches); j++) {
+	    const struct evdev_udev_tag_match match = evdev_udev_tag_matches[j];
+
+		if(uhdf->type & match.tag)
+		    tags |= match.tag;
 	}
 
 	return tags;
@@ -1778,13 +1807,18 @@
 	enum evdev_device_udev_tags udev_tags;
 	unsigned int tablet_tags;
 	struct evdev_dispatch *dispatch;
+ 
+	udev_tags = evdev_device_get_udev_tags(device, device->uhdf);
+	
+	device->model_flags = udev_tags;
 
-	udev_tags = evdev_device_get_udev_tags(device, device->udev_device);
+    libinput_log_printf("----evdev_configure_device  tagged as supported input device---- %d \r\n", udev_tags);
 
 	if ((udev_tags & EVDEV_UDEV_TAG_INPUT) == 0 ||
 	    (udev_tags & ~EVDEV_UDEV_TAG_INPUT) == 0) {
 		evdev_log_info(device,
 			       "not tagged as supported input device\n");
+        libinput_log_printf("----evdev_configure_device not tagged as supported input device---- \r\n");
 		return NULL;
 	}
 
@@ -1812,12 +1846,6 @@
 		evdev_disable_accelerometer_axes(device);
 	}
 
-	if (udev_tags == (EVDEV_UDEV_TAG_INPUT|EVDEV_UDEV_TAG_JOYSTICK)) {
-		evdev_log_info(device,
-			       "device is a joystick, ignoring\n");
-		return NULL;
-	}
-
 	if (evdev_reject_device(device)) {
 		evdev_log_info(device, "was rejected\n");
 		return NULL;
@@ -1833,8 +1861,16 @@
 			udev_tags &= ~EVDEV_UDEV_TAG_TOUCHSCREEN;
 	}
 
+    if (udev_tags & EVDEV_UDEV_TAG_JOYSTICK) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_JOYSTICK_BULID-- \r\n");
+        dispatch = evdev_joystick_create(device);
+        device->seat_caps |= EVDEV_DEVICE_JOYSTICK;
+		return dispatch;
+    }
+
 	if (evdev_device_has_model_quirk(device,
 					 QUIRK_MODEL_DELL_CANVAS_TOTEM)) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TOTEM_BULID-- \r\n");
 		dispatch = evdev_totem_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET;
 		evdev_log_info(device, "device is a totem\n");
@@ -1850,12 +1886,14 @@
 
 	/* libwacom assigns tablet _and_ tablet_pad to the pad devices */
 	if (udev_tags & EVDEV_UDEV_TAG_TABLET_PAD) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TABLET_PAD_BULID-- \r\n");
 		dispatch = evdev_tablet_pad_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET_PAD;
 		evdev_log_info(device, "device is a tablet pad\n");
 		return dispatch;
 
 	} else if ((udev_tags & tablet_tags) == EVDEV_UDEV_TAG_TABLET) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TABLET_BULID-- \r\n");
 		dispatch = evdev_tablet_create(device);
 		device->seat_caps |= EVDEV_DEVICE_TABLET;
 		evdev_log_info(device, "device is a tablet\n");
@@ -1863,6 +1901,7 @@
 	}
 
 	if (udev_tags & EVDEV_UDEV_TAG_TOUCHPAD) {
+        libinput_log_printf("----evdev_configure_device--_LIBINPUT_TOUCHPAD_BULID-- \r\n");
 		if (udev_tags & EVDEV_UDEV_TAG_TABLET)
 			evdev_tag_tablet_touchpad(device);
 		/* whether velocity should be averaged, false by default */
@@ -1874,8 +1913,8 @@
 
 	if (udev_tags & EVDEV_UDEV_TAG_MOUSE ||
 	    udev_tags & EVDEV_UDEV_TAG_POINTINGSTICK) {
-		evdev_tag_external_mouse(device, device->udev_device);
-		evdev_tag_trackpoint(device, device->udev_device);
+		evdev_tag_external_mouse(device, device->uhdf);
+		evdev_tag_trackpoint(device, device->uhdf);
 		device->dpi = evdev_read_dpi_prop(device);
 		device->trackpoint_multiplier = evdev_get_trackpoint_multiplier(device);
 		/* whether velocity should be averaged, false by default */
@@ -1906,7 +1945,7 @@
 			device->seat_caps |= EVDEV_DEVICE_POINTER;
 		}
 
-		evdev_tag_keyboard(device, device->udev_device);
+		evdev_tag_keyboard(device);
 	}
 
 	if (udev_tags & EVDEV_UDEV_TAG_TOUCHSCREEN) {
@@ -1987,38 +2026,18 @@
 }
 
 static bool
-evdev_device_have_same_syspath(struct udev_device *udev_device, int fd)
+evdev_device_have_same_syspath(struct uhdf *uhdf, int fd)
 {
-	struct udev *udev = udev_device_get_udev(udev_device);
-	struct udev_device *udev_device_new = NULL;
-	struct stat st;
-	bool rc = false;
-
-	if (fstat(fd, &st) < 0)
-		goto out;
-
-	udev_device_new = udev_device_new_from_devnum(udev, 'c', st.st_rdev);
-	if (!udev_device_new)
-		goto out;
-
-	rc = streq(udev_device_get_syspath(udev_device_new),
-		   udev_device_get_syspath(udev_device));
-out:
-	if (udev_device_new)
-		udev_device_unref(udev_device_new);
-	return rc;
+	return false;
 }
 
 static bool
 evdev_set_device_group(struct evdev_device *device,
-		       struct udev_device *udev_device)
+		       struct uhdf *uhdf)
 {
 	struct libinput *libinput = evdev_libinput_context(device);
 	struct libinput_device_group *group = NULL;
-	const char *udev_group;
-
-	udev_group = udev_device_get_property_value(udev_device,
-						    "LIBINPUT_DEVICE_GROUP");
+	const char *udev_group = "LIBINPUT_DEVICE_GROUP";
 	if (udev_group)
 		group = libinput_device_group_find_group(libinput, udev_group);
 
@@ -2078,7 +2097,7 @@
 	 * unnecessary wakeups but on some devices we need to watch it for
 	 * pointer jumps */
 	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
+	q = quirks_fetch_for_device(quirks, device->uhdf);
 	if (!q ||
 	    !quirks_get_string(q, QUIRK_ATTR_MSC_TIMESTAMP, &prop) ||
 	    !streq(prop, "watch")) {
@@ -2145,11 +2164,11 @@
 }
 
 static bool
-udev_device_should_be_ignored(struct udev_device *udev_device)
+udev_device_should_be_ignored(struct uhdf *uhdf)
 {
 	const char *value;
 
-	value = udev_device_get_property_value(udev_device,
+	value = uhdf_device_get_property_value(uhdf,
 					       "LIBINPUT_IGNORE_DEVICE");
 
 	return value && !streq(value, "0");
@@ -2157,73 +2176,38 @@
 
 struct evdev_device *
 evdev_device_create(struct libinput_seat *seat,
-		    struct udev_device *udev_device)
+		    struct uhdf *uhdf)
 {
+    char devname[256]={0};
 	struct libinput *libinput = seat->libinput;
 	struct evdev_device *device = NULL;
 	int rc;
-	int fd;
 	int unhandled_device = 0;
-	const char *devnode = udev_device_get_devnode(udev_device);
-	const char *sysname = udev_device_get_sysname(udev_device);
-
-	if (!devnode) {
-		log_info(libinput, "%s: no device node associated\n", sysname);
-		return NULL;
-	}
-
-	if (udev_device_should_be_ignored(udev_device)) {
-		log_debug(libinput, "%s: device is ignored\n", sysname);
-		return NULL;
-	}
-
-	int loop_count = 0;
-	loop_open_restricted:
-	/* Use non-blocking mode so that we can loop on read on
-	 * evdev_device_data() until all events on the fd are
-	 * read.  mtdev_get() also expects this. */
-	fd = open_restricted(libinput, devnode,
-			     O_RDWR | O_NONBLOCK | O_CLOEXEC);
-	loop_count++;
-	if (fd < 0) {
-		log_info(libinput,
-			 "%s: opening input device '%s' failed (%s).\n",
-			 sysname,
-			 devnode,
-			 strerror(-fd));
-		if (loop_count < MAX_RETRY_OPEN_DEVICE_COUNT) {
-			usleep(1 * 1000);
-			goto loop_open_restricted;
-		}
-		return NULL;
-	}
-
-	if (!evdev_device_have_same_syspath(udev_device, fd))
-		goto err;
 
 	device = zalloc(sizeof *device);
 
 	libinput_device_init(&device->base, seat);
 	libinput_seat_ref(seat);
 
-	evdev_drain_fd(fd);
-
-	rc = libevdev_new_from_fd(fd, &device->evdev);
+	rc = libevdev_new_from_index(uhdf->index, &device->evdev,uhdf->fn);
 	if (rc != 0)
 		goto err;
-
-	libevdev_set_clock_id(device->evdev, CLOCK_MONOTONIC);
+ 
 	libevdev_set_device_log_function(device->evdev,
 					 libevdev_log_func,
 					 LIBEVDEV_LOG_ERROR,
 					 libinput);
 	device->seat_caps = 0;
 	device->is_mt = 0;
+	device->udev_device = NULL;
 	device->mtdev = NULL;
-	device->udev_device = udev_device_ref(udev_device);
+	device->uhdf = uhdf;
 	device->dispatch = NULL;
-	device->fd = fd;
-	device->devname = libevdev_get_name(device->evdev);
+	device->fd = -1;//uhdf->index;
+    device->source = NULL;
+    device->output_name = NULL;
+    sprintf(devname,"HDI_%2d",uhdf->index);
+	device->devname = strdup(devname);//libevdev_get_name(device->evdev);
 	device->scroll.threshold = 5.0; /* Default may be overridden */
 	device->scroll.direction_lock_threshold = 5.0; /* Default may be overridden */
 	device->scroll.direction = 0;
@@ -2231,7 +2215,7 @@
 		evdev_read_wheel_click_props(device);
 	device->model_flags = evdev_read_model_flags(device);
 	device->dpi = DEFAULT_MOUSE_DPI;
-
+    libinput->device[uhdf->index] = device;
 	/* at most 5 SYN_DROPPED log-messages per 30s */
 	ratelimit_init(&device->syn_drop_limit, s2us(30), 5);
 	/* at most 5 "delayed processing" log messages per hour */
@@ -2242,19 +2226,18 @@
 	matrix_init_identity(&device->abs.calibration);
 	matrix_init_identity(&device->abs.usermatrix);
 	matrix_init_identity(&device->abs.default_calibration);
-
+ 
 	evdev_pre_configure_model_quirks(device);
-
+  
 	device->dispatch = evdev_configure_device(device);
 	if (device->dispatch == NULL || device->seat_caps == 0)
-		goto err;
-
-	device->source =
-		libinput_add_fd(libinput, fd, evdev_device_dispatch, device);
+		goto err; 
+  
+  	device->source = NULL;
+/*		libinput_add_fd(libinput, libinput->pipes[0], evdev_device_hdfdispatch, libinput);
 	if (!device->source)
-		goto err;
-
-	if (!evdev_set_device_group(device, udev_device))
+		goto err;*/
+	if (!evdev_set_device_group(device, uhdf))
 		goto err;
 
 	list_insert(seat->devices_list.prev, &device->base.link);
@@ -2264,7 +2247,6 @@
 	return device;
 
 err:
-	close_restricted(libinput, fd);
 	if (device) {
 		unhandled_device = device->seat_caps == 0;
 		evdev_device_destroy(device);
@@ -2282,7 +2264,7 @@
 const char *
 evdev_device_get_sysname(struct evdev_device *device)
 {
-	return udev_device_get_sysname(device->udev_device);
+	return "hdf_path";
 }
 
 const char *
@@ -2306,7 +2288,8 @@
 struct udev_device *
 evdev_device_get_udev_device(struct evdev_device *device)
 {
-	return udev_device_ref(device->udev_device);
+
+	return NULL;
 }
 
 void
@@ -2387,7 +2370,7 @@
 	const char *prop;
 	float calibration[6];
 
-	prop = udev_device_get_property_value(device->udev_device,
+	prop = uhdf_device_get_property_value(device->uhdf,
 					      "LIBINPUT_CALIBRATION_MATRIX");
 
 	if (prop == NULL)
@@ -2423,7 +2406,7 @@
 	if (rc == -1)
 		return 0;
 
-	prop = udev_device_get_property_value(device->udev_device, name);
+	prop = uhdf_device_get_property_value(device->uhdf, name);
 	if (prop && (safe_atoi(prop, &fuzz) == false || fuzz < 0)) {
 		evdev_log_bug_libinput(device,
 				       "invalid LIBINPUT_FUZZ property value: %s\n",
@@ -2476,6 +2459,9 @@
 		return !!(device->seat_caps & EVDEV_DEVICE_TABLET_PAD);
 	case LIBINPUT_DEVICE_CAP_SWITCH:
 		return !!(device->seat_caps & EVDEV_DEVICE_SWITCH);
+	case LIBINPUT_DEVICE_CAP_JOYSTICK:
+		return !!(device->seat_caps & EVDEV_DEVICE_JOYSTICK);
+
 	default:
 		return false;
 	}
@@ -2751,64 +2737,6 @@
 int
 evdev_device_resume(struct evdev_device *device)
 {
-	struct libinput *libinput = evdev_libinput_context(device);
-	int fd;
-	const char *devnode;
-	struct input_event ev;
-	enum libevdev_read_status status;
-
-	if (device->fd != -1)
-		return 0;
-
-	if (device->was_removed)
-		return -ENODEV;
-
-	devnode = udev_device_get_devnode(device->udev_device);
-	if (!devnode)
-		return -ENODEV;
-
-	fd = open_restricted(libinput, devnode,
-			     O_RDWR | O_NONBLOCK | O_CLOEXEC);
-
-	if (fd < 0)
-		return -errno;
-
-	if (!evdev_device_have_same_syspath(device->udev_device, fd)) {
-		close_restricted(libinput, fd);
-		return -ENODEV;
-	}
-
-	evdev_drain_fd(fd);
-
-	device->fd = fd;
-
-	if (evdev_need_mtdev(device)) {
-		device->mtdev = mtdev_new_open(device->fd);
-		if (!device->mtdev)
-			return -ENODEV;
-	}
-
-	libevdev_change_fd(device->evdev, fd);
-	libevdev_set_clock_id(device->evdev, CLOCK_MONOTONIC);
-
-	/* re-sync libevdev's view of the device, but discard the actual
-	   events. Our device is in a neutral state already */
-	libevdev_next_event(device->evdev,
-			    LIBEVDEV_READ_FLAG_FORCE_SYNC,
-			    &ev);
-	do {
-		status = libevdev_next_event(device->evdev,
-					     LIBEVDEV_READ_FLAG_SYNC,
-					     &ev);
-	} while (status == LIBEVDEV_READ_STATUS_SYNC);
-
-	device->source =
-		libinput_add_fd(libinput, fd, evdev_device_dispatch, device);
-	if (!device->source) {
-		mtdev_close_delete(device->mtdev);
-		return -ENOMEM;
-	}
-
 	evdev_notify_resumed_device(device);
 
 	return 0;
@@ -2861,12 +2789,12 @@
 		libinput_device_group_unref(device->base.group);
 
 	free(device->output_name);
+    free((char*)device->devname);
 	filter_destroy(device->pointer.filter);
 	libinput_timer_destroy(&device->scroll.timer);
 	libinput_timer_destroy(&device->middlebutton.timer);
 	libinput_seat_unref(device->base.seat);
 	libevdev_free(device->evdev);
-	udev_device_unref(device->udev_device);
 	free(device);
 }
 
diff -Naur old/src/evdev.h new/src/evdev.h
--- old/src/evdev.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/evdev.h	2021-01-01 00:00:00.000000000 +0800
@@ -61,6 +61,7 @@
 	EVDEV_DEVICE_TABLET_PAD		= bit(4),
 	EVDEV_DEVICE_GESTURE		= bit(5),
 	EVDEV_DEVICE_SWITCH		= bit(6),
+	EVDEV_DEVICE_JOYSTICK = bit(7),
 };
 
 enum evdev_device_tags {
@@ -76,6 +77,11 @@
 	EVDEV_TAG_TABLET_TOUCHPAD	= bit(9),
 };
 
+struct evdev_udev_tag_match {
+    const char* name;
+    enum evdev_device_udev_tags tag;
+};
+
 enum evdev_middlebutton_state {
 	MIDDLEBUTTON_IDLE,
 	MIDDLEBUTTON_LEFT_DOWN,
@@ -159,6 +165,8 @@
 	ARBITRATION_IGNORE_RECT,
 };
 
+struct uhdf;
+
 struct evdev_device {
 	struct libinput_device base;
 
@@ -269,6 +277,7 @@
 		uint32_t button_mask;
 		uint64_t first_event_time;
 	} middlebutton;
+	struct uhdf *uhdf;
 };
 
 static inline struct evdev_device *
@@ -353,6 +362,7 @@
 	DISPATCH_TABLET,
 	DISPATCH_TABLET_PAD,
 	DISPATCH_TOTEM,
+	DISPATCH_JOYSTICK,
 };
 
 struct evdev_dispatch {
@@ -375,7 +385,7 @@
 
 struct evdev_device *
 evdev_device_create(struct libinput_seat *seat,
-		    struct udev_device *device);
+		    struct uhdf *uhdf);
 
 static inline struct libinput *
 evdev_libinput_context(const struct evdev_device *device)
@@ -386,19 +396,8 @@
 static inline bool
 evdev_device_has_model_quirk(struct evdev_device *device,
 			     enum quirk model_quirk)
-{
-	struct quirks_context *quirks;
-	struct quirks *q;
-	bool result = false;
-
-	assert(quirk_get_name(model_quirk) != NULL);
-
-	quirks = evdev_libinput_context(device)->quirks;
-	q = quirks_fetch_for_device(quirks, device->udev_device);
-	quirks_get_bool(q, model_quirk, &result);
-	quirks_unref(q);
-
-	return result;
+{  
+	return model_quirk == (enum quirk)(device->uhdf->modeltype);
 }
 
 void
@@ -430,6 +429,10 @@
 evdev_device_init_pointer_acceleration(struct evdev_device *device,
 				       struct motion_filter *filter);
 
+struct evdev_dispatch* 
+evdev_joystick_create(struct evdev_device* device);
+
+
 struct evdev_dispatch *
 evdev_touchpad_create(struct evdev_device *device);
 
@@ -481,6 +484,11 @@
 struct udev_device *
 evdev_device_get_udev_device(struct evdev_device *device);
 
+/**  @brief   获取设备类型 */
+enum evdev_device_udev_tags 
+evdev_device_get_udev_device_tags(struct evdev_device* device);
+
+
 void
 evdev_device_set_default_calibration(struct evdev_device *device,
 				     const float calibration[6]);
@@ -1005,7 +1013,8 @@
 				   "Axis %#x value %d is outside expected range [%d, %d]\n"
 				   "See %sabsolute_coordinate_ranges.html for details\n",
 				   code, value, min, max,
-				   HTTP_DOC_LINK);
+				   "");
+				//HTTP_DOC_LINK);
 	}
 }
 
@@ -1024,4 +1033,7 @@
 	free(kbd);
 }
 
+const char *  uhdf_device_get_property_value(struct uhdf *uhdf,
+						   const char *key);
+
 #endif /* EVDEV_H */
diff -Naur old/src/libinput-git-version.h new/src/libinput-git-version.h
--- old/src/libinput-git-version.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/libinput-git-version.h	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,3 @@
+#pragma once
+
+#define LIBINPUT_GIT_VERSION "@VCS_TAG@"
diff -Naur old/src/libinput-private.h new/src/libinput-private.h
--- old/src/libinput-private.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/libinput-private.h	2021-01-01 00:00:00.000000000 +0800
@@ -30,7 +30,7 @@
 #include <errno.h>
 #include <math.h>
 #include <stdarg.h>
-
+#include <stdatomic.h>
 #if HAVE_LIBWACOM
 #include <libwacom/libwacom.h>
 #endif
@@ -118,7 +118,7 @@
 	int (*device_change_seat)(struct libinput_device *device,
 				  const char *seat_name);
 };
-
+#define PIPE_NUM 64
 struct libinput {
 	int epoll_fd;
 	struct list source_destroy_list;
@@ -162,6 +162,14 @@
 		size_t refcount;
 	} libwacom;
 #endif
+    int pipes[2];
+    atomic_int pipesbytes;
+    atomic_int pipesbytesbyindex[PIPE_NUM];
+    bool pipesstatus[PIPE_NUM];
+    struct evdev_device *device[PIPE_NUM];
+    int devpipes[2];
+    struct libinput_source *devsource;
+    struct libinput_source *eventsource;
 };
 
 typedef void (*libinput_seat_destroy_func) (struct libinput_seat *seat);
@@ -600,7 +608,8 @@
 		     enum libinput_event_type type,
 		     int finger_count,
 		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel);
+		     const struct normalized_coords *unaccel,
+		     const struct sloted_coords_info *raw_touches);
 
 void
 gesture_notify_swipe_end(struct libinput_device *device,
@@ -867,5 +876,6 @@
 static inline void libinput_libwacom_unref(struct libinput *li) {}
 #endif
 
+struct libinput * uhdflibinput_unref(struct libinput *libinput);
 
 #endif /* LIBINPUT_PRIVATE_H */
diff -Naur old/src/libinput-util.c new/src/libinput-util.c
--- old/src/libinput-util.c	1970-01-01 08:00:00.000000000 +0800
+++ new/src/libinput-util.c	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,102 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2013-2015 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * This list data structure is verbatim copy from wayland-util.h from the
+ * Wayland project; except that wl_ prefix has been removed.
+ */
+
+#include "libinput-util.h"
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+
+static FILE* p_log_fp = NULL;
+
+FILE *libinput_get_log_fp()
+{
+    if (p_log_fp == NULL) {
+        const char *pLogDir = getenv("LIBINPUT_LOG_DIR");
+        if (pLogDir == NULL) {
+            pLogDir = (char *)_LIBINPUT_LOG_DIR;
+        }
+
+        const int r = mkdir(pLogDir, 0755);
+        if (r < 0 && errno != EEXIST) {
+            const int saved_errno = errno;
+            printf("could not create %s, errno: %d\n", pLogDir, saved_errno);
+            return NULL;
+        }
+
+        const char *p_log_path = getenv("LIBINPUT_LOG_PATH");
+        if (p_log_path == NULL) {
+            p_log_path = (char *)_LIBINPUT_LOG_PATH;
+        }
+        p_log_fp = fopen(p_log_path, "w+");
+    }
+
+    return p_log_fp;
+}
+
+void libinput_log_printf(const char* fmt, ...)
+{
+    p_log_fp = libinput_get_log_fp();    
+#ifdef HAVE_LIBINPUT_LOG_CONSOLE_ENABLE
+    char buf[1024] = {0};
+
+    va_list args;
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    buf[1024 - 1] = '\0';
+    
+    printf("%s\n", buf);
+
+    if (p_log_fp != NULL) {
+        fputs(buf, p_log_fp);
+        fflush(p_log_fp);
+    }
+#else
+    if (p_log_fp != NULL) {
+        va_list args;
+        va_start(args, fmt);
+        vfprintf(p_log_fp, fmt, args);
+        va_end(args);
+        fflush(p_log_fp);
+    }
+#endif
+}
+
+uint64_t getMicrotime()
+{
+    struct timeval currentTime;
+    gettimeofday(&currentTime, NULL);
+    return currentTime.tv_sec * 1000000 + currentTime.tv_usec;
+}
+
+uint64_t getTranTime(struct input_event *event)
+{
+    return event->input_event_sec * 1000000 + event->input_event_usec;
+}
+#endif
diff -Naur old/src/libinput-util.h new/src/libinput-util.h
--- old/src/libinput-util.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/libinput-util.h	2021-01-01 00:00:00.000000000 +0800
@@ -27,10 +27,9 @@
 
 #include "config.h"
 
-#ifdef NDEBUG
-#warning "libinput relies on assert(). #defining NDEBUG is not recommended"
-#endif
-
+//#ifdef NDEBUG
+//#warning "libinput relies on assert(). #defining NDEBUG is not recommended"
+//#endif
 
 #include "libinput.h"
 
@@ -57,6 +56,15 @@
 #define DEFAULT_MOUSE_DPI 1000
 #define DEFAULT_TRACKPOINT_SENSITIVITY 128
 
+
+#ifdef HAVE_LIBINPUT_LOG_ENABLE
+void libinput_log_printf(const char* fmt, ...);
+uint64_t getMicrotime();
+uint64_t getTranTime(struct input_event *event);
+#else
+#define libinput_log_printf(fmt, ...)
+#endif
+
 #define trace(...) \
 	do { \
 	printf("%s() - \033[0;31m", __func__); \
diff -Naur old/src/libinput-version.h new/src/libinput-version.h
--- old/src/libinput-version.h	1970-01-01 08:00:00.000000000 +0800
+++ new/src/libinput-version.h	2021-01-01 00:00:00.000000000 +0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright © 2013 Jonas Ådahl
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBINPUT_VERSION_H
+#define LIBINPUT_VERSION_H
+
+#define LIBINPUT_VERSION_MAJOR //@LIBINPUT_VERSION_MAJOR@
+#define LIBINPUT_VERSION_MINOR //@LIBINPUT_VERSION_MINOR@
+#define LIBINPUT_VERSION_MICRO //@LIBINPUT_VERSION_MICRO@
+#define LIBINPUT_VERSION "@LIBINPUT_VERSION@"
+
+#endif
diff -Naur old/src/libinput.c new/src/libinput.c
--- old/src/libinput.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/libinput.c	2021-01-01 00:00:00.000000000 +0800
@@ -33,12 +33,13 @@
 #include <sys/epoll.h>
 #include <unistd.h>
 #include <assert.h>
-
+#include <stdatomic.h>
 #include "libinput.h"
 #include "libinput-private.h"
 #include "evdev.h"
 #include "timer.h"
 #include "quirks.h"
+#include "evdev-joystick.h"
 
 #define require_event_type(li_, type_, retval_, ...)	\
 	if (type_ == LIBINPUT_EVENT_NONE) abort(); \
@@ -193,6 +194,7 @@
 	int cancelled;
 	struct normalized_coords delta;
 	struct normalized_coords delta_unaccel;
+	struct sloted_coords_info solt_touches;
 	double scale;
 	double angle;
 };
@@ -1031,6 +1033,18 @@
 	return event->angle;
 }
 
+LIBINPUT_EXPORT struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(
+	struct libinput_event_gesture *event)
+{
+	require_event_type(libinput_event_get_context(&event->base),
+			   event->base.type,
+			   NULL,
+			   LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE);
+
+	return &event->solt_touches;
+}
+
 LIBINPUT_EXPORT int
 libinput_event_tablet_tool_x_has_changed(
 				struct libinput_event_tablet_tool *event)
@@ -1757,7 +1771,122 @@
 	source->fd = -1;
 	list_insert(&libinput->source_destroy_list, &source->link);
 }
+extern void *
+libinput_load_module(const char *name, const char *entrypoint);
+typedef int (*HdfDevHandle)(int index,int cmd);
+static void
+evdev_dev_handler(void *data)
+{ 
+    struct libinput *libinput = (struct libinput *)data;
+    int cmd[2];
+    int len = sizeof(int);
+    static HdfDevHandle handle = NULL;
+    printf("libinput_add_fd epoll_fd =%d,fd=%d ,function addr = %p \n",libinput->epoll_fd,libinput->devpipes[0], evdev_dev_handler);
+    if( handle == NULL) {
+        handle = (HdfDevHandle)libinput_load_module("libmmi-server.z.so","HdfDevHandle");
+    }
+    {
+        len = read(libinput->devpipes[0],cmd,sizeof(cmd));
+        //printf("evdev_dev_handler cmd len =%d\n" ,len);
+        if(len >= 0 ) {
+            if(handle) {
+                handle(cmd[0],cmd[1]);
+            }
+        }
+    }
+    return;
+}
+void uhdflibinput_unpipe(struct libinput *libinput)
+{
+    close(libinput->devpipes[0]);
+    close(libinput->devpipes[1]);
+    close(libinput->pipes[0]);
+    close(libinput->pipes[1]);
+}
+bool libinput_pipe(struct libinput *libinput) {
+	  
+  
+	libinput->pipes[0]=-1;
+    libinput->pipes[1]=-1;
+    libinput->pipesbytes = 0;
+    if (0 != pipe(libinput->pipes)) {
+		return false;
+	}
+    if (fcntl(libinput->pipes[0], F_SETFL, O_NONBLOCK) == -1) {
+		return false;
+	}
+    if (fcntl(libinput->pipes[1], F_SETFL, O_NONBLOCK) == -1) {
+		return false;
+	}
+    libinput->devpipes[0]=-1;
+    libinput->devpipes[1]=-1;
+    if (0 != pipe(libinput->devpipes)) {
+		    return false;
+	}
+    
+
+    libinput->devsource = libinput_add_fd(libinput,
+						     libinput->devpipes[0],
+						     evdev_dev_handler,
+						     libinput);
+	if (!libinput->devsource) {
+		return false;
+	}
+
+	libinput->eventsource =
+		libinput_add_fd(libinput, libinput->pipes[0], evdev_device_hdfdispatch, libinput);
+	if (!libinput->eventsource) {
+		return false;
+    }
+    libinput->pipesbytes = 0 ;
+	return true;
+}
+
+/**
+* Write in a pipe.
+*/
+LIBINPUT_EXPORT int libinput_pipe_write(struct libinput *libinput, int index , const void *buf, int count) {
+    int readcount =atomic_load_explicit(&libinput->pipesbytes,__ATOMIC_SEQ_CST);
+ 
+    if(readcount > 56*1024) { // more then 56k data will be discard
+        libinput->pipesstatus[index] = true; 
+    }
+    if(readcount < 1024) {//less then 1k data will  do translate  
+        libinput->pipesstatus[index] = false; 
+    }
+    if(!libinput->pipesstatus[index]) {
+        write(libinput->pipes[1], buf, count);
+        atomic_fetch_add_explicit(&libinput->pipesbytes, count, memory_order_release);
+    }
+    return count ;
+}
 
+
+LIBINPUT_EXPORT int libinput_get_pipe_bytes(struct libinput *libinput, int index) {
+    return libinput->pipesbytes;
+}
+		  
+/**
+* Read in a pipe.
+*/
+LIBINPUT_EXPORT int libinput_pipe_read(struct libinput *libinput,  int index , void *buf, int count) {
+	return (int) read(libinput->pipes[0], buf, count);
+}
+
+/**
+* Write in a pipe.
+*/
+LIBINPUT_EXPORT int libinput_devpipe_write(struct libinput *libinput, void *buf, int count) {
+	return (int) write(libinput->devpipes[1], buf, count);
+}
+		  
+/**
+* Read in a pipe.
+*/
+LIBINPUT_EXPORT int libinput_devpipe_read(struct libinput *libinput,void *buf, int count) {
+		  
+	return (int) read(libinput->devpipes[0], buf, count);
+}
 int
 libinput_init(struct libinput *libinput,
 	      const struct libinput_interface *interface,
@@ -1770,7 +1899,11 @@
 	libinput->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
 	if (libinput->epoll_fd < 0)
 		return -1;
-
+    if (!libinput_pipe(libinput)) {
+        uhdflibinput_unpipe(libinput);
+        close(libinput->epoll_fd);
+        return -1;
+    }
 	libinput->events_len = 4;
 	libinput->events = zalloc(libinput->events_len * sizeof(*libinput->events));
 	libinput->log_handler = libinput_default_log_func;
@@ -1806,11 +1939,8 @@
 	/* If we fail, we'll fail next time too */
 	libinput->quirks_initialized = true;
 
-	data_path = getenv("LIBINPUT_QUIRKS_DIR");
-	if (!data_path) {
-		data_path = LIBINPUT_QUIRKS_DIR;
-		override_file = LIBINPUT_QUIRKS_OVERRIDE_FILE;
-	}
+		data_path = (char *)LIBINPUT_QUIRKS_DIR;
+		override_file = (char *)LIBINPUT_QUIRKS_OVERRIDE_FILE;
 
 	quirks = quirks_init_subsystem(data_path,
 				       override_file,
@@ -1856,10 +1986,9 @@
 	return libinput;
 }
 
-LIBINPUT_EXPORT struct libinput *
-libinput_unref(struct libinput *libinput)
+struct libinput * uhdflibinput_unref(struct libinput *libinput)
 {
-	struct libinput_event *event;
+    struct libinput_event *event;
 	struct libinput_device *device, *next_device;
 	struct libinput_seat *seat, *next_seat;
 	struct libinput_tablet_tool *tool, *next_tool;
@@ -1873,10 +2002,6 @@
 	if (libinput->refcount > 0)
 		return libinput;
 
-	libinput_suspend(libinput);
-
-	libinput->interface_backend->destroy(libinput);
-
 	while ((event = libinput_get_event(libinput)))
 	       libinput_event_destroy(event);
 
@@ -1901,16 +2026,25 @@
 	list_for_each_safe(tool, next_tool, &libinput->tool_list, link) {
 		libinput_tablet_tool_unref(tool);
 	}
-
+    libinput_remove_source(libinput,libinput->devsource);
+    libinput_remove_source(libinput,libinput->eventsource);
+    uhdflibinput_unpipe(libinput);
 	libinput_timer_subsys_destroy(libinput);
 	libinput_drop_destroyed_sources(libinput);
-	quirks_context_unref(libinput->quirks);
 	close(libinput->epoll_fd);
 	free(libinput);
 
 	return NULL;
 }
 
+LIBINPUT_EXPORT struct libinput *
+libinput_unref(struct libinput *libinput)
+{
+    uhdflibinput_unref(libinput);
+
+	return NULL;
+}
+
 static void
 libinput_event_tablet_tool_destroy(struct libinput_event_tablet_tool *event)
 {
@@ -2311,6 +2445,9 @@
 	case LIBINPUT_DEVICE_CAP_SWITCH:
 		capability = "CAP_SWITCH";
 		break;
+	case LIBINPUT_DEVICE_CAP_JOYSTICK:
+        capability = "CAP_JOYSTICK";
+        break;
 	}
 
 	log_bug_libinput(device->seat->libinput,
@@ -2814,6 +2951,7 @@
 	       int cancelled,
 	       const struct normalized_coords *delta,
 	       const struct normalized_coords *unaccel,
+	       const struct sloted_coords_info *solt_touches,
 	       double scale,
 	       double angle)
 {
@@ -2834,6 +2972,12 @@
 		.angle = angle,
 	};
 
+	if (solt_touches != NULL) {
+		gesture_event->solt_touches = *solt_touches;
+	} else {
+        memset(&gesture_event->solt_touches, 0, sizeof(struct sloted_coords_info));
+    }
+
 	post_device_event(device, time, type,
 			  &gesture_event->base);
 }
@@ -2844,9 +2988,10 @@
 		     enum libinput_event_type type,
 		     int finger_count,
 		     const struct normalized_coords *delta,
-		     const struct normalized_coords *unaccel)
+		     const struct normalized_coords *unaccel, 
+		     const struct sloted_coords_info *solt_touches)
 {
-	gesture_notify(device, time, type, finger_count, 0, delta, unaccel,
+	gesture_notify(device, time, type, finger_count, 0, delta, unaccel, solt_touches,
 		       0.0, 0.0);
 }
 
@@ -2859,7 +3004,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_SWIPE_END,
-		       finger_count, cancelled, &zero, &zero, 0.0, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, 0.0, 0.0);
 }
 
 void
@@ -2873,7 +3018,7 @@
 		     double angle)
 {
 	gesture_notify(device, time, type, finger_count, 0,
-		       delta, unaccel, scale, angle);
+		       delta, unaccel, NULL, scale, angle);
 }
 
 void
@@ -2886,7 +3031,7 @@
 	const struct normalized_coords zero = { 0.0, 0.0 };
 
 	gesture_notify(device, time, LIBINPUT_EVENT_GESTURE_PINCH_END,
-		       finger_count, cancelled, &zero, &zero, scale, 0.0);
+		       finger_count, cancelled, &zero, &zero, NULL, scale, 0.0);
 }
 
 void
@@ -2972,6 +3117,92 @@
 	libinput->events_in = (libinput->events_in + 1) % libinput->events_len;
 }
 
+
+LIBINPUT_EXPORT void
+libinput_post_handle_event(struct libinput* libinput, struct libinput_event* event)
+{
+	libinput_post_event(libinput, event);
+}
+
+LIBINPUT_EXPORT struct libinput_event_joystick_button*
+libinput_event_get_joystick_button_event(struct libinput_event* event)
+{
+    require_event_type(libinput_event_get_context(event),
+        event->type,
+        NULL,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return (struct libinput_event_joystick_button*)event;
+}
+
+LIBINPUT_EXPORT struct libinput_event_joystick_axis*
+libinput_event_get_joystick_axis_event(struct libinput_event* event)
+{
+	require_event_type(libinput_event_get_context(event),
+        event->type,
+        NULL,
+		LIBINPUT_EVENT_POINTER_AXIS);
+
+    return (struct libinput_event_joystick_axis*)event;
+}
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+bool libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis)
+{
+	if (event == NULL) {
+		return 0;
+	}
+
+	return (bool)(event->axis_value_mask & (uint32_t)axis);
+}
+
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event)
+{
+	if (event == NULL) {
+		return 0;
+	}
+
+	return event->time;
+}
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis)
+{
+	switch (axis) {
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X:
+	return &event->abs_x;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y:
+	return &event->abs_y;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z:
+	return &event->abs_z;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX:
+	return &event->abs_rx;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY:
+	return &event->abs_ry;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ:
+	return &event->abs_rz;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE:
+	return &event->abs_throttle;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X:
+	return &event->abs_hat0x;
+	case LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y:
+	return &event->abs_hat0y;
+	default:
+	break;
+	}
+
+	return NULL;
+}
+
 LIBINPUT_EXPORT struct libinput_event *
 libinput_get_event(struct libinput *libinput)
 {
@@ -3016,13 +3247,13 @@
 LIBINPUT_EXPORT int
 libinput_resume(struct libinput *libinput)
 {
-	return libinput->interface_backend->resume(libinput);
+	return 0; 
 }
 
 LIBINPUT_EXPORT void
 libinput_suspend(struct libinput *libinput)
 {
-	libinput->interface_backend->suspend(libinput);
+
 }
 
 LIBINPUT_EXPORT void
@@ -3055,12 +3286,37 @@
 	return evdev_device_get_sysname((struct evdev_device *) device);
 }
 
+LIBINPUT_EXPORT const char*
+libinput_device_get_phys(struct libinput_device* device)
+{
+	struct libevdev* evdev = ((struct evdev_device*)device)->evdev;
+	if (evdev == NULL) {
+		return NULL;
+	}
+	return libevdev_get_phys(evdev);
+}
+
 LIBINPUT_EXPORT const char *
 libinput_device_get_name(struct libinput_device *device)
 {
 	return evdev_device_get_name((struct evdev_device *) device);
 }
 
+LIBINPUT_EXPORT enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device)
+{
+	if(device == NULL)
+        return EVDEV_UDEV_TAG_INPUT;
+
+	struct evdev_device* evdevDevice = (struct evdev_device*)device;
+	enum evdev_device_udev_tags udev_tags;
+    
+	if (evdevDevice->udev_device)
+	    return EVDEV_UDEV_TAG_INPUT;
+	
+	return udev_tags = (enum evdev_device_udev_tags)evdevDevice->model_flags;
+}
+
 LIBINPUT_EXPORT unsigned int
 libinput_device_get_id_product(struct libinput_device *device)
 {
@@ -3076,7 +3332,7 @@
 LIBINPUT_EXPORT const char *
 libinput_device_get_output_name(struct libinput_device *device)
 {
-	return evdev_device_get_output((struct evdev_device *) device);
+    return NULL;
 }
 
 LIBINPUT_EXPORT struct libinput_seat *
@@ -4378,3 +4634,93 @@
 	}
 }
 #endif
+
+LIBINPUT_EXPORT struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event)
+{
+	if (!event)
+		return 0;
+
+	require_event_type(libinput_event_get_context(event),
+		event->type,
+		NULL,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+	return (struct libinput_event_joystick_button*)event;
+}
+
+LIBINPUT_EXPORT uint64_t
+libinput_event_joystick_button_time(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+        event->base.type,
+        0,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return event->time;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return event->key;
+}
+
+LIBINPUT_EXPORT enum libinput_key_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event)
+{
+	if (!event)
+		return 0;
+
+	require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+		0,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+	return event->state;
+}
+
+LIBINPUT_EXPORT uint32_t
+libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+		LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return event->seat_key_count;
+}
+
+LIBINPUT_EXPORT int
+libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event)
+{
+    if (!event)
+        return 0;
+
+    require_event_type(libinput_event_get_context(&event->base),
+		event->base.type,
+        0,
+        LIBINPUT_EVENT_POINTER_BUTTON);
+
+    return event->value;
+}
+
+LIBINPUT_EXPORT double
+libinput_event_get_touch_pressure(struct libinput_event *event)
+{
+    return 0.0F;
+}
diff -Naur old/src/libinput.h new/src/libinput.h
--- old/src/libinput.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/libinput.h	2021-01-01 00:00:00.000000000 +0800
@@ -33,6 +33,7 @@
 #include <stdint.h>
 #include <stdarg.h>
 #include <libudev.h>
+#include "util-bits.h"
 
 #define LIBINPUT_ATTRIBUTE_PRINTF(_format, _args) \
 	__attribute__ ((format (printf, _format, _args)))
@@ -196,6 +197,22 @@
 	LIBINPUT_DEVICE_CAP_TABLET_PAD = 4,
 	LIBINPUT_DEVICE_CAP_GESTURE = 5,
 	LIBINPUT_DEVICE_CAP_SWITCH = 6,
+	LIBINPUT_DEVICE_CAP_JOYSTICK = 7,
+};
+
+enum evdev_device_udev_tags {
+    EVDEV_UDEV_TAG_INPUT = bit(0),
+    EVDEV_UDEV_TAG_KEYBOARD = bit(1),
+    EVDEV_UDEV_TAG_MOUSE = bit(2),
+    EVDEV_UDEV_TAG_TOUCHPAD = bit(3),
+    EVDEV_UDEV_TAG_TOUCHSCREEN = bit(4),
+    EVDEV_UDEV_TAG_TABLET = bit(5),
+    EVDEV_UDEV_TAG_JOYSTICK = bit(6),
+    EVDEV_UDEV_TAG_ACCELEROMETER = bit(7),
+    EVDEV_UDEV_TAG_TABLET_PAD = bit(8),
+    EVDEV_UDEV_TAG_POINTINGSTICK = bit(9),
+    EVDEV_UDEV_TAG_TRACKBALL = bit(10),
+    EVDEV_UDEV_TAG_SWITCH = bit(11),
 };
 
 /**
@@ -315,6 +332,49 @@
 };
 
 /**
+ * @ingroup event_joystick
+ *
+ * The source for a @ref LIBINPUT_EVENT_POINTER_AXIS event. See
+ * libinput_event_get_joystick_axis_event() for details.
+ *
+ * @since 1.16.4
+ */
+enum libinput_joystick_axis_source {
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_UNKNOW = 0,
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_X = bit(0),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Y = bit(1),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_Z = bit(2),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RX = bit(3),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RY = bit(4),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RZ = bit(5),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_THROTTLE = bit(6),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_RUDDER = bit(7),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_WHEEL = bit(8),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_GAS = bit(9),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_BRAKE = bit(10),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0X = bit(11),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT0Y = bit(12),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1X = bit(13),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT1Y = bit(14),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2X = bit(15),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT2Y = bit(16),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3X = bit(17),
+	LIBINPUT_JOYSTICK_AXIS_SOURCE_ABS_HAT3Y = bit(18),
+};
+
+#define MAX_SOLTED_COORDS_NUM 10
+struct sloted_coords {
+	bool is_active;
+	float x;
+	float y;
+};
+
+struct sloted_coords_info {
+	struct sloted_coords coords[MAX_SOLTED_COORDS_NUM];
+	unsigned int active_count;
+};
+
+/**
  * @ingroup device
  *
  * Available tool types for a device with the @ref
@@ -387,6 +447,17 @@
 	LIBINPUT_TABLET_TOOL_TIP_DOWN = 1,
 };
 
+struct libinput_event_joystick_axis_abs_info {
+	int32_t code;
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+	float	standardValue;
+};
+
 /**
  * @defgroup tablet_pad_modes Tablet pad modes
  *
@@ -1893,6 +1964,12 @@
 libinput_event_gesture_get_angle_delta(struct libinput_event_gesture *event);
 
 /**
+ * 获取带slot的touches信息, 仅支持LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE
+ */
+struct sloted_coords_info *
+libinput_event_gesture_get_solt_touches(struct libinput_event_gesture *event);
+
+/**
  * @defgroup event_tablet Tablet events
  *
  * Events that come from tools on tablet devices. For events from the pad,
@@ -3466,6 +3543,46 @@
 int
 libinput_dispatch(struct libinput *libinput);
 
+/****************************************************************************
+* @brief : brief
+* @author : fms
+* @date : 2021/3/8 20:55
+* @version : ver 1.0
+* @inparam :libinput  event
+* @outparam :
+*****************************************************************************/
+void
+libinput_post_handle_event(struct libinput* libinput,
+	struct libinput_event* event);
+
+/****************************************************************************
+* @brief : get joystick button event
+* @author : fms
+* @date : 2021/3/12 10:56
+* @version : ver 1.0
+* @inparam : 
+* @outparam : 
+*****************************************************************************/
+struct libinput_event_joystick_axis *
+libinput_event_get_joystick_axis_event(struct libinput_event *event);
+
+/**
+ * @brief 获取轴事件的时间
+ */
+uint64_t
+libinput_event_get_joystick_axis_time(struct libinput_event_joystick_axis *event);
+
+/**
+ * @brief 获取joystick指定轴的数据是否变化
+*/
+bool libinput_event_get_joystick_axis_value_is_changed(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
+/**
+ * @brief 获取joystick指定轴的abs信息
+*/
+struct libinput_event_joystick_axis_abs_info *
+libinput_event_get_joystick_axis_abs_info(struct libinput_event_joystick_axis *event, enum libinput_joystick_axis_source axis);
+
 /**
  * @ingroup base
  *
@@ -3936,6 +4053,10 @@
 const char *
 libinput_device_get_name(struct libinput_device *device);
 
+/**  @brief   获取设备类型*/
+enum evdev_device_udev_tags
+libinput_device_get_tags(struct libinput_device* device);
+
 /**
  * @ingroup device
  *
@@ -5928,7 +6049,96 @@
 unsigned int
 libinput_device_config_rotation_get_default_angle(struct libinput_device *device);
 
+struct uhdf;
+
+int uhdfdevice_added(struct libinput *input,struct uhdf *uhdf,const char *seat_name);
+
+struct libinput * libinput_hdf_create_context(const struct libinput_interface *interface,void *user_data);
+
+void uhdfdevice_removed(struct uhdf *uhdf);
+
+struct evdev_device;
+struct input_event;
+void evdev_device_dispatch_two(struct evdev_device *device,
+                struct input_event *ev);
+
+/**
+ * @ingroup event
+ *
+ * Get the struct libinput_event_joystick_button from the event.
+ *
+ * @param event The libinput event
+ * @return The libinput_event_joystick_button for this event.
+ */
+struct libinput_event_joystick_button*
+libinput_event_get_joystick_pointer_button_event(struct libinput_event* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the time from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The time for this event.
+ */
+uint64_t libinput_event_joystick_button_time(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the key value from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The key value for this event.
+ */
+uint32_t libinput_event_joystick_button_get_key(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the seat key count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The seat key count for this event.
+ */
+uint32_t libinput_event_joystick_button_get_seat_key_count(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup event
+ *
+ * Get the value count from the event.
+ *
+ * @param event The libinput_event_joystick_button
+ * @return The value for this event.
+ */
+int libinput_event_joystick_button_get_value(struct libinput_event_joystick_button* event);
+
+/**
+ * @ingroup config
+ *
+ * Get the pressure of the touch screen
+ *
+ * @param Carried libinput event
+ * @return Pressure value of touch screen
+ * 
+ * @since 1.4
+ */
+double
+libinput_event_get_touch_pressure(struct libinput_event* event);
+
+const char*
+libinput_device_get_phys(struct libinput_device* device);bool libinput_pipe(struct libinput *libinput);
+bool libinput_pipe(struct libinput *libinput);
+int libinput_pipe_write(struct libinput *libinput, int index,const void *buf, int count);
+int libinput_pipe_read(struct libinput *libinput, int index,void *buf, int count);
+int libinput_devpipe_write(struct libinput *libinput,void *buf, int count);
+int libinput_devpipe_read(struct libinput *libinput, void *buf, int count);
+int libinput_get_pipe_bytes(struct libinput *libinput, int index);
+void evdev_device_hdfdispatch(void *data);
+enum libinput_key_state
+libinput_event_joystick_button_get_key_state(struct libinput_event_joystick_button* event);
 #ifdef __cplusplus
 }
 #endif
 #endif /* LIBINPUT_H */
+
diff -Naur old/src/path-seat.c new/src/path-seat.c
--- old/src/path-seat.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/path-seat.c	2021-01-01 00:00:00.000000000 +0800
@@ -176,42 +176,7 @@
 		   struct udev_device *udev_device,
 		   const char *seat_logical_name_override)
 {
-	struct path_seat *seat;
-	struct evdev_device *device = NULL;
-	const char *output_name;
-	const char *devnode, *sysname;
-
-	devnode = udev_device_get_devnode(udev_device);
-	sysname = udev_device_get_sysname(udev_device);
-
-	seat = path_seat_get_for_device(input, udev_device, seat_logical_name_override);
-	if (!seat)
-		goto out;
-
-	device = evdev_device_create(&seat->base, udev_device);
-	libinput_seat_unref(&seat->base);
-
-	if (device == EVDEV_UNHANDLED_DEVICE) {
-		device = NULL;
-		log_info(&input->base,
-			 "%-7s - not using input device '%s'.\n",
-			 sysname,
-			 devnode);
-		goto out;
-	} else if (device == NULL) {
-		log_info(&input->base,
-			 "%-7s - failed to create input device '%s'.\n",
-			 sysname,
-			 devnode);
-		goto out;
-	}
-
-	evdev_read_calibration_prop(device);
-	output_name = udev_device_get_property_value(udev_device, "WL_OUTPUT");
-	device->output_name = safe_strdup(output_name);
-
-out:
-	return device ? &device->base : NULL;
+    return NULL;
 }
 
 static int
@@ -277,19 +242,7 @@
 path_device_change_seat(struct libinput_device *device,
 			const char *seat_name)
 {
-	struct libinput *libinput = device->seat->libinput;
-	struct evdev_device *evdev = evdev_device(device);
-	struct udev_device *udev_device = NULL;
-	int rc = -1;
-
-	udev_device = evdev->udev_device;
-	udev_device_ref(udev_device);
-	libinput_path_remove_device(device);
-
-	if (path_create_device(libinput, udev_device, seat_name) != NULL)
-		rc = 0;
-	udev_device_unref(udev_device);
-	return rc;
+	return -1;
 }
 
 static const struct libinput_interface_backend interface_backend = {
@@ -404,26 +357,5 @@
 LIBINPUT_EXPORT void
 libinput_path_remove_device(struct libinput_device *device)
 {
-	struct libinput *libinput = device->seat->libinput;
-	struct path_input *input = (struct path_input*)libinput;
-	struct libinput_seat *seat;
-	struct evdev_device *evdev = evdev_device(device);
-	struct path_device *dev;
-
-	if (libinput->interface_backend != &interface_backend) {
-		log_bug_client(libinput, "Mismatching backends.\n");
-		return;
-	}
-
-	list_for_each(dev, &input->path_list, link) {
-		if (dev->udev_device == evdev->udev_device) {
-			path_device_destroy(dev);
-			break;
-		}
-	}
-
-	seat = device->seat;
-	libinput_seat_ref(seat);
-	path_disable_device(libinput, evdev);
-	libinput_seat_unref(seat);
+    // hdf no need
 }
diff -Naur old/src/quirks.c new/src/quirks.c
--- old/src/quirks.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/quirks.c	2021-01-01 00:00:00.000000000 +0800
@@ -1382,36 +1382,9 @@
 
 struct quirks *
 quirks_fetch_for_device(struct quirks_context *ctx,
-			struct udev_device *udev_device)
+            struct uhdf *uhdf)
 {
-	struct quirks *q = NULL;
-	struct section *s;
-	struct match *m;
-
-	if (!ctx)
-		return NULL;
-
-	qlog_debug(ctx, "%s: fetching quirks\n",
-		   udev_device_get_devnode(udev_device));
-
-	q = quirks_new();
-
-	m = match_new(udev_device, ctx->dmi, ctx->dt);
-
-	list_for_each(s, &ctx->sections, link) {
-		quirk_match_section(ctx, q, s, m, udev_device);
-	}
-
-	match_free(m);
-
-	if (q->nproperties == 0) {
-		quirks_unref(q);
-		return NULL;
-	}
-
-	list_insert(&ctx->quirks, &q->link);
-
-	return q;
+	return uhdf->quirkpop;
 }
 
 
diff -Naur old/src/quirks.h new/src/quirks.h
--- old/src/quirks.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/quirks.h	2021-01-01 00:00:00.000000000 +0800
@@ -31,6 +31,7 @@
 #include <libudev.h>
 
 #include "libinput.h"
+#include "udev-seat.h"
 
 /**
  * Handle to the quirks context.
@@ -189,7 +190,7 @@
  */
 struct quirks *
 quirks_fetch_for_device(struct quirks_context *ctx,
-			struct udev_device *device);
+			struct uhdf *uhdf);
 
 /**
  * Reduce the refcount by one. When the refcount reaches zero, the
diff -Naur old/src/udev-seat.c new/src/udev-seat.c
--- old/src/udev-seat.c	2021-01-01 00:00:00.000000000 +0800
+++ new/src/udev-seat.c	2021-01-01 00:00:00.000000000 +0800
@@ -27,10 +27,17 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
-
+#include <dlfcn.h>
 #include "evdev.h"
 #include "udev-seat.h"
 
+#ifdef __aarch64__
+#define LIB_MODULEDIR "/system/lib64"
+#define MODULEDIR "/system/lib64"
+#else
+#define LIB_MODULEDIR "/system/lib"
+#define MODULEDIR "/system/lib"
+#endif
 static const char default_seat[] = "seat0";
 static const char default_seat_name[] = "default";
 
@@ -40,6 +47,86 @@
 		 const char *seat_name);
 static struct udev_seat *
 udev_seat_get_named(struct udev_input *input, const char *seat_name);
+size_t
+module_path_from_env(const char *name, char *path, size_t path_len)
+{
+	const char *mapping = getenv("WESTON_MODULE_MAP");
+	const char *end;
+	const int name_len = strlen(name);
+
+	if (!mapping)
+		return 0;
+
+	end = mapping + strlen(mapping);
+	while (mapping < end && *mapping) {
+		const char *filename, *next;
+
+		/* early out: impossibly short string */
+		if (end - mapping < name_len + 1)
+			return 0;
+
+		filename = &mapping[name_len + 1];
+		next = strchrnul(mapping, ';');
+
+		if (strncmp(mapping, name, name_len) == 0 &&
+		    mapping[name_len] == '=') {
+			size_t file_len = next - filename; /* no trailing NUL */
+			if (file_len >= path_len)
+				return 0;
+			strncpy(path, filename, file_len);
+			path[file_len] = '\0';
+			return file_len;
+		}
+
+		mapping = next + 1;
+	}
+
+	return 0;
+}
+
+void *
+libinput_load_module(const char *name, const char *entrypoint)
+{
+	char path[PATH_MAX];
+	void *module, *init;
+	size_t len;
+
+	if (name == NULL)
+		return NULL;
+	if (name[0] != '/') {
+		len = module_path_from_env(name, path, sizeof path);
+		if (len == 0)
+			len = snprintf(path, sizeof path, "%s/%s",
+				       LIB_MODULEDIR, name);
+	} else {
+		len = snprintf(path, sizeof path, "%s", name);
+	}
+    len = snprintf(path, sizeof path, "%s", name);
+	/* snprintf returns the length of the string it would've written,
+	 * _excluding_ the NUL byte. So even being equal to the size of
+	 * our buffer is an error here. */
+	if (len >= sizeof path)
+		return NULL;
+
+	module = dlopen(path, RTLD_NOW | RTLD_NOLOAD);
+	if (module) {
+		libinput_log_printf("Module '%s' already loaded\n", path);
+	} else {
+		libinput_log_printf("Loading module '%s'\n", path);
+		module = dlopen(path, RTLD_NOW);
+		if (!module) {
+			libinput_log_printf("Failed to load module: %s\n", dlerror());
+			return NULL;
+		}
+	}
+
+	init = dlsym(module, entrypoint);
+	if (!init) {
+		return NULL;
+	}
+
+	return init;
+}
 
 
 static inline bool
@@ -78,90 +165,12 @@
 	     struct udev_input *input,
 	     const char *seat_name)
 {
-	struct evdev_device *device;
-	const char *devnode, *sysname;
-	const char *device_seat, *output_name;
-	struct udev_seat *seat;
-
-	device_seat = udev_device_get_property_value(udev_device, "ID_SEAT");
-	if (!device_seat)
-		device_seat = default_seat;
-
-	if (!streq(device_seat, input->seat_id))
-		return 0;
-
-	if (ignore_litest_test_suite_device(udev_device))
-		return 0;
-
-	devnode = udev_device_get_devnode(udev_device);
-	sysname = udev_device_get_sysname(udev_device);
-
-	/* Search for matching logical seat */
-	if (!seat_name)
-		seat_name = udev_device_get_property_value(udev_device, "WL_SEAT");
-	if (!seat_name)
-		seat_name = default_seat_name;
-
-	seat = udev_seat_get_named(input, seat_name);
-
-	/* There is a race at startup: a device added between setting
-	 * up the udev monitor and enumerating all current devices may show
-	 * up in both lists. Filter those out.
-	 */
-	if (filter_duplicates(seat, udev_device))
-		return 0;
-
-	if (seat)
-		libinput_seat_ref(&seat->base);
-	else {
-		seat = udev_seat_create(input, device_seat, seat_name);
-		if (!seat)
-			return -1;
-	}
-
-	device = evdev_device_create(&seat->base, udev_device);
-	libinput_seat_unref(&seat->base);
-
-	if (device == EVDEV_UNHANDLED_DEVICE) {
-		log_info(&input->base,
-			 "%-7s - not using input device '%s'\n",
-			 sysname,
-			 devnode);
-		return 0;
-	} else if (device == NULL) {
-		log_info(&input->base,
-			 "%-7s - failed to create input device '%s'\n",
-			 sysname,
-			 devnode);
-		return 0;
-	}
-
-	evdev_read_calibration_prop(device);
-
-	output_name = udev_device_get_property_value(udev_device, "WL_OUTPUT");
-	device->output_name = safe_strdup(output_name);
-
 	return 0;
 }
 
 static void
 device_removed(struct udev_device *udev_device, struct udev_input *input)
 {
-	struct evdev_device *device, *next;
-	struct udev_seat *seat;
-	const char *syspath;
-
-	syspath = udev_device_get_syspath(udev_device);
-	list_for_each(seat, &input->base.seat_list, base.link) {
-		list_for_each_safe(device, next,
-				   &seat->base.devices_list, base.link) {
-			if (streq(syspath,
-				  udev_device_get_syspath(device->udev_device))) {
-				evdev_device_remove(device);
-				break;
-			}
-		}
-	}
 }
 
 static int
@@ -368,55 +377,36 @@
 udev_device_change_seat(struct libinput_device *device,
 			const char *seat_name)
 {
-	struct libinput *libinput = device->seat->libinput;
-	struct udev_input *input = (struct udev_input *)libinput;
-	struct evdev_device *evdev = evdev_device(device);
-	struct udev_device *udev_device = evdev->udev_device;
-	int rc;
-
-	udev_device_ref(udev_device);
-	device_removed(udev_device, input);
-	rc = device_added(udev_device, input, seat_name);
-	udev_device_unref(udev_device);
-
-	return rc;
+    return 0;
 }
-
+#if 0
 static const struct libinput_interface_backend interface_backend = {
 	.resume = udev_input_enable,
 	.suspend = udev_input_disable,
 	.destroy = udev_input_destroy,
 	.device_change_seat = udev_device_change_seat,
 };
-
+#endif
+typedef struct libinput *  (*HdfAdfInit)();
 LIBINPUT_EXPORT struct libinput *
 libinput_udev_create_context(const struct libinput_interface *interface,
 			     void *user_data,
 			     struct udev *udev)
 {
-	struct udev_input *input;
-
-	if (!interface || !udev)
-		return NULL;
-
-	input = zalloc(sizeof *input);
-
-	if (libinput_init(&input->base, interface,
-			  &interface_backend, user_data) != 0) {
-		libinput_unref(&input->base);
-		free(input);
-		return NULL;
-	}
-
-	input->udev = udev_ref(udev);
-
-	return &input->base;
+    HdfAdfInit init = (HdfAdfInit)libinput_load_module("libmmi-server.z.so","HdfAdfInit");
+    if(init == NULL) {
+        return NULL;
+    }
+     struct libinput * plibinput = init();
+     libinput_set_user_data(plibinput,user_data);
+     return plibinput;
 }
 
 LIBINPUT_EXPORT int
 libinput_udev_assign_seat(struct libinput *libinput,
 			  const char *seat_id)
 {
+#if 0
 	struct udev_input *input = (struct udev_input*)libinput;
 
 	if (!seat_id)
@@ -447,6 +437,109 @@
 
 	if (udev_input_enable(&input->base) < 0)
 		return -1;
-
+#endif
 	return 0;
 }
+
+// change libinput for hdf frame
+static const struct libinput_interface_backend simplyinterface_backend = {
+    .resume = NULL,
+    .suspend = NULL,
+    .destroy = NULL,
+    .device_change_seat = NULL,
+};
+
+static struct udev_seat *
+uhdf_seat_get_named(struct uhdf_input *input, const char *seat_name)
+{
+    struct udev_seat *seat;
+
+    list_for_each(seat, &input->base.seat_list, base.link) {
+        if (streq(seat->base.logical_name, seat_name))
+            return seat;
+    }
+
+    return NULL;
+}
+
+static struct udev_seat *
+uhdf_seat_create(struct uhdf_input *input,
+    const char *device_seat,
+    const char *seat_name)
+{
+    struct udev_seat *seat;
+
+    seat = zalloc(sizeof *seat);
+
+    libinput_seat_init(&seat->base, &input->base,
+            device_seat, seat_name,
+            udev_seat_destroy);
+
+    return seat;
+}
+
+struct libinput *
+libinput_hdf_create_context(const struct libinput_interface *interface,
+                           void *user_data)
+{
+    struct uhdf_input *input;		  
+    input = zalloc(sizeof *input);
+
+    if (libinput_init(&input->base, interface,
+        &simplyinterface_backend, user_data) != 0) {
+            free(input);
+            return NULL;
+    }			
+
+    return &input->base;
+}
+
+void uhdfdevice_removed(struct uhdf *uhdf)
+{
+    evdev_device_remove(uhdf->device);
+}
+
+int
+uhdfdevice_added(struct libinput  *libinput,
+		  struct uhdf *uhdf,
+		  const char *seat_name)
+{ 
+    struct uhdf_input *input =(struct uhdf_input *)libinput; 
+	struct udev_seat *seat;
+	struct evdev_device *device;
+	const char *device_seat;
+    device_seat = default_seat;
+
+	if (!seat_name)
+		seat_name = default_seat_name;
+
+	seat = uhdf_seat_get_named(input, seat_name);	 
+
+	if (seat)
+		libinput_seat_ref(&seat->base);
+	else {
+		seat = uhdf_seat_create(input, device_seat, seat_name);
+		if (!seat)
+		return -1;
+	}
+    
+	device = evdev_device_create(&seat->base, uhdf);
+	libinput_seat_unref(&seat->base);
+	 
+	if (device == EVDEV_UNHANDLED_DEVICE) {
+	    log_info(&input->base,
+				  "- not using input device \n");
+			return 0;
+	} else if (device == NULL) {
+		log_info(&input->base,
+				  " - failed to create input device\n");
+		return 0;
+	}
+    
+	uhdf->device = device;
+    libinput->pipesbytesbyindex[uhdf->index] = 0;
+    libinput->pipesstatus[uhdf->index] = false ;
+	evdev_read_calibration_prop(device);
+	 	 
+    return 0;
+}
diff -Naur old/src/udev-seat.h new/src/udev-seat.h
--- old/src/udev-seat.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/udev-seat.h	2021-01-01 00:00:00.000000000 +0800
@@ -41,4 +41,23 @@
 	char *seat_id;
 };
 
+struct quirks;
+struct uhdf
+{
+    int index;
+    int type;
+    int modeltype;
+    int prop;
+    struct quirks *quirkpop;
+    int nproperties;
+    int (*fn)(int index,int code, void * iobuff);
+    struct evdev_device *device;
+    void * deviceinfo;
+};
+
+struct uhdf_input {
+	struct libinput base;
+	char *seat_id;
+};
+
 #endif
diff -Naur old/src/util-strings.h new/src/util-strings.h
--- old/src/util-strings.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/util-strings.h	2021-01-01 00:00:00.000000000 +0800
@@ -281,7 +281,7 @@
 	if (npairs == 0)
 		goto error;
 
-	result = zalloc(npairs * sizeof *result);
+	result = (struct key_value_double *)zalloc(npairs * sizeof *result);
 
 	for (pair = pairs; *pair; pair++) {
 		char **kv = strv_from_string(*pair, kv_separator);
diff -Naur old/src/util-time.h new/src/util-time.h
--- old/src/util-time.h	2021-01-01 00:00:00.000000000 +0800
+++ new/src/util-time.h	2021-01-01 00:00:00.000000000 +0800
@@ -97,7 +97,8 @@
 static inline struct human_time
 to_human_time(uint64_t us)
 {
-	struct human_time t;
+	uint64_t l = 0;
+	struct human_time t = {0, NULL};
 	struct c {
 		const char *unit;
 		unsigned int change_from_previous;
@@ -108,7 +109,7 @@
 		{"s", 1000, 120},
 		{"min", 60, 120},
 		{"h", 60, 48},
-		{"d", 24, ~0},
+		{"d", 24, ~l},
 	};
 	struct c *c;
 	uint64_t value = us;
@@ -121,6 +122,6 @@
 			return t;
 		}
 	}
-
-	assert(!"We should never get here");
+return t;
+	//assert(1);
 }
diff -Naur old/tools/libinput-debug-events.c new/tools/libinput-debug-events.c
--- old/tools/libinput-debug-events.c	2021-01-01 00:00:00.000000000 +0800
+++ new/tools/libinput-debug-events.c	2021-01-01 00:00:00.000000000 +0800
@@ -274,6 +274,10 @@
 					   LIBINPUT_DEVICE_CAP_SWITCH))
 		printq("S");
 
+    if (libinput_device_has_capability(dev,
+        LIBINPUT_DEVICE_CAP_JOYSTICK))
+        printq("JOYSTICK");
+
 	if (libinput_device_get_size(dev, &w, &h) == 0)
 		printq("  size %.0fx%.0fmm", w, h);
 
diff -Naur old/udev/libinput-device-group.c new/udev/libinput-device-group.c
--- old/udev/libinput-device-group.c	2021-01-01 00:00:00.000000000 +0800
+++ new/udev/libinput-device-group.c	2021-01-01 00:00:00.000000000 +0800
@@ -138,7 +138,7 @@
 				*product_id = pid;
 				best_dist = dist;
 
-				free(*phys_attr);
+				free((char*)*phys_attr);
 				*phys_attr = strdup(phys);
 			}
 		}
